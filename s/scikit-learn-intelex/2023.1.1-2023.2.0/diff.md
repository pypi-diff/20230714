# Comparing `tmp/scikit_learn_intelex-2023.1.1-py39-none-win_amd64.whl.zip` & `tmp/scikit_learn_intelex-2023.2.0-py39-none-macosx_10_15_x86_64.macosx_11_0_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,90 +1,92 @@
-Zip file size: 125052 bytes, number of entries: 88
--rw-rw-rw-  2.0 fat     1512 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/__init__.py
--rw-rw-rw-  2.0 fat     1968 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/__main__.py
--rw-rw-rw-  2.0 fat     3928 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_config.py
--rw-rw-rw-  2.0 fat     7075 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_device_offload.py
--rw-rw-rw-  2.0 fat     2907 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_utils.py
--rw-rw-rw-  2.0 fat     9597 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/dispatcher.py
--rw-rw-rw-  2.0 fat      843 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/basic_statistics/__init__.py
--rw-rw-rw-  2.0 fat      796 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/basic_statistics/basic_statistics.py
--rw-rw-rw-  2.0 fat      874 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/__init__.py
--rw-rw-rw-  2.0 fat      827 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/dbscan.py
--rw-rw-rw-  2.0 fat      827 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/k_means.py
--rw-rw-rw-  2.0 fat     1236 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/tests/test_dbscan.py
--rw-rw-rw-  2.0 fat     1251 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/tests/test_kmeans.py
--rw-rw-rw-  2.0 fat      826 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/__init__.py
--rw-rw-rw-  2.0 fat      830 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/pca.py
--rw-rw-rw-  2.0 fat     1165 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/tests/test_pca.py
--rw-rw-rw-  2.0 fat    21773 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/doc/third-party-programs.txt
--rw-rw-rw-  2.0 fat      895 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/__init__.py
--rw-rw-rw-  2.0 fat      849 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/forest.py
--rw-rw-rw-  2.0 fat     2036 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/tests/test_random_forest.py
--rw-rw-rw-  2.0 fat     2507 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/glob/__main__.py
--rw-rw-rw-  2.0 fat     3063 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/glob/dispatcher.py
--rw-rw-rw-  2.0 fat     1120 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/__init__.py
--rw-rw-rw-  2.0 fat      843 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/coordinate_descent.py
--rw-rw-rw-  2.0 fat      821 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/linear.py
--rw-rw-rw-  2.0 fat      870 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/logistic_path.py
--rw-rw-rw-  2.0 fat      831 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/ridge.py
--rw-rw-rw-  2.0 fat     2404 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/tests/test_linear.py
--rw-rw-rw-  2.0 fat     1194 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/tests/test_logreg.py
--rw-rw-rw-  2.0 fat      830 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/__init__.py
--rw-rw-rw-  2.0 fat      826 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/t_sne.py
--rw-rw-rw-  2.0 fat     1082 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/tests/test_tsne.py
--rw-rw-rw-  2.0 fat      928 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/__init__.py
--rw-rw-rw-  2.0 fat      866 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/pairwise.py
--rw-rw-rw-  2.0 fat      857 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/ranking.py
--rw-rw-rw-  2.0 fat     1592 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/tests/test_metrics.py
--rw-rw-rw-  2.0 fat      863 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/__init__.py
--rw-rw-rw-  2.0 fat      871 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/split.py
--rw-rw-rw-  2.0 fat     1277 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/tests/test_model_selection.py
--rw-rw-rw-  2.0 fat     1086 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/__init__.py
--rw-rw-rw-  2.0 fat    19426 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_classification.py
--rw-rw-rw-  2.0 fat    17868 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_regression.py
--rw-rw-rw-  2.0 fat    14858 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_unsupervised.py
--rw-rw-rw-  2.0 fat    15130 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/lof.py
--rw-rw-rw-  2.0 fat     2203 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/tests/test_neighbors.py
--rw-rw-rw-  2.0 fat      822 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/__init__.py
--rw-rw-rw-  2.0 fat      826 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/__init__.py
--rw-rw-rw-  2.0 fat    13883 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/pca.py
--rw-rw-rw-  2.0 fat     1221 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/tests/test_preview_pca.py
--rw-rw-rw-  2.0 fat      917 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/__init__.py
--rw-rw-rw-  2.0 fat    48478 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/forest.py
--rw-rw-rw-  2.0 fat     1831 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/tests/test_random_preview_forest.py
--rw-rw-rw-  2.0 fat      863 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/__init__.py
--rw-rw-rw-  2.0 fat     2180 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/_common.py
--rw-rw-rw-  2.0 fat    10284 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/linear.py
--rw-rw-rw-  2.0 fat     1525 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/tests/test_preview_linear.py
--rw-rw-rw-  2.0 fat      833 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/__init__.py
--rw-rw-rw-  2.0 fat      821 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/basic_statistics/__init__.py
--rw-rw-rw-  2.0 fat      886 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/basic_statistics/basic_statistics.py
--rw-rw-rw-  2.0 fat      784 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/decomposition/__init__.py
--rw-rw-rw-  2.0 fat      871 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/decomposition/pca.py
--rw-rw-rw-  2.0 fat      873 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/ensemble/__init__.py
--rw-rw-rw-  2.0 fat     3103 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/ensemble/forest.py
--rw-rw-rw-  2.0 fat      819 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/linear_model/__init__.py
--rw-rw-rw-  2.0 fat      883 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/linear_model/linear_model.py
--rw-rw-rw-  2.0 fat      906 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/neighbors/__init__.py
--rw-rw-rw-  2.0 fat      939 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/neighbors/neighbors.py
--rw-rw-rw-  2.0 fat     1076 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/__init__.py
--rw-rw-rw-  2.0 fat     6119 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/_common.py
--rw-rw-rw-  2.0 fat     8469 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/nusvc.py
--rw-rw-rw-  2.0 fat     5146 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/nusvr.py
--rw-rw-rw-  2.0 fat     9285 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/svc.py
--rw-rw-rw-  2.0 fat     5142 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/svr.py
--rw-rw-rw-  2.0 fat     2626 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/tests/test_svm.py
--rw-rw-rw-  2.0 fat     4683 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/_models_info.py
--rw-rw-rw-  2.0 fat     1407 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_config.py
--rw-rw-rw-  2.0 fat     7314 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_memory_usage.py
--rw-rw-rw-  2.0 fat     7523 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_monkeypatch.py
--rw-rw-rw-  2.0 fat     2773 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_patching.py
--rw-rw-rw-  2.0 fat    14286 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_run_to_run_stability_tests.py
--rw-rw-rw-  2.0 fat     3778 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/utils/_launch_algorithms.py
--rw-rw-rw-  2.0 fat      838 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/utils/__init__.py
--rw-rw-rw-  2.0 fat      874 b- defN 23-Mar-31 13:38 scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/utils/validation.py
--rw-rw-rw-  2.0 fat    10999 b- defN 23-Apr-01 04:28 scikit_learn_intelex-2023.1.1.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat    12394 b- defN 23-Apr-01 04:28 scikit_learn_intelex-2023.1.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       99 b- defN 23-Apr-01 04:28 scikit_learn_intelex-2023.1.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        1 b- defN 23-Apr-01 04:28 scikit_learn_intelex-2023.1.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat    12875 b- defN 23-Apr-01 04:28 scikit_learn_intelex-2023.1.1.dist-info/RECORD
-88 files, 368486 bytes uncompressed, 102456 bytes compressed:  72.2%
+Zip file size: 124482 bytes, number of entries: 90
+-rw-r--r--  2.0 unx     1582 b- defN 23-Jun-13 11:30 sklearnex/__init__.py
+-rw-r--r--  2.0 unx     1968 b- defN 23-Jun-13 11:30 sklearnex/__main__.py
+-rw-r--r--  2.0 unx     3928 b- defN 23-Jun-13 11:30 sklearnex/_config.py
+-rw-r--r--  2.0 unx     7006 b- defN 23-Jun-13 11:30 sklearnex/_device_offload.py
+-rw-r--r--  2.0 unx     3031 b- defN 23-Jun-13 11:30 sklearnex/_utils.py
+-rw-r--r--  2.0 unx    10423 b- defN 23-Jun-13 11:30 sklearnex/dispatcher.py
+-rw-r--r--  2.0 unx      843 b- defN 23-Jun-13 11:30 sklearnex/basic_statistics/__init__.py
+-rw-r--r--  2.0 unx      796 b- defN 23-Jun-13 11:30 sklearnex/basic_statistics/basic_statistics.py
+-rw-r--r--  2.0 unx      874 b- defN 23-Jun-13 11:30 sklearnex/cluster/__init__.py
+-rw-r--r--  2.0 unx      827 b- defN 23-Jun-13 11:30 sklearnex/cluster/dbscan.py
+-rw-r--r--  2.0 unx      827 b- defN 23-Jun-13 11:30 sklearnex/cluster/k_means.py
+-rw-r--r--  2.0 unx     1236 b- defN 23-Jun-13 11:30 sklearnex/cluster/tests/test_dbscan.py
+-rw-r--r--  2.0 unx     1251 b- defN 23-Jun-13 11:30 sklearnex/cluster/tests/test_kmeans.py
+-rw-r--r--  2.0 unx      826 b- defN 23-Jun-13 11:30 sklearnex/decomposition/__init__.py
+-rw-r--r--  2.0 unx      830 b- defN 23-Jun-13 11:30 sklearnex/decomposition/pca.py
+-rw-r--r--  2.0 unx     1165 b- defN 23-Jun-13 11:30 sklearnex/decomposition/tests/test_pca.py
+-rw-r--r--  2.0 unx    21773 b- defN 23-Jun-13 11:30 sklearnex/doc/third-party-programs.txt
+-rw-r--r--  2.0 unx      895 b- defN 23-Jun-13 11:30 sklearnex/ensemble/__init__.py
+-rw-r--r--  2.0 unx      849 b- defN 23-Jun-13 11:30 sklearnex/ensemble/forest.py
+-rw-r--r--  2.0 unx     2036 b- defN 23-Jun-13 11:30 sklearnex/ensemble/tests/test_forest.py
+-rw-r--r--  2.0 unx     2507 b- defN 23-Jun-13 11:30 sklearnex/glob/__main__.py
+-rw-r--r--  2.0 unx     3063 b- defN 23-Jun-13 11:30 sklearnex/glob/dispatcher.py
+-rw-r--r--  2.0 unx     1120 b- defN 23-Jun-13 11:30 sklearnex/linear_model/__init__.py
+-rw-r--r--  2.0 unx      843 b- defN 23-Jun-13 11:30 sklearnex/linear_model/coordinate_descent.py
+-rw-r--r--  2.0 unx      821 b- defN 23-Jun-13 11:30 sklearnex/linear_model/linear.py
+-rw-r--r--  2.0 unx      870 b- defN 23-Jun-13 11:30 sklearnex/linear_model/logistic_path.py
+-rw-r--r--  2.0 unx      831 b- defN 23-Jun-13 11:30 sklearnex/linear_model/ridge.py
+-rw-r--r--  2.0 unx     2404 b- defN 23-Jun-13 11:30 sklearnex/linear_model/tests/test_linear.py
+-rw-r--r--  2.0 unx     1194 b- defN 23-Jun-13 11:30 sklearnex/linear_model/tests/test_logreg.py
+-rw-r--r--  2.0 unx      830 b- defN 23-Jun-13 11:30 sklearnex/manifold/__init__.py
+-rw-r--r--  2.0 unx      826 b- defN 23-Jun-13 11:30 sklearnex/manifold/t_sne.py
+-rw-r--r--  2.0 unx     1082 b- defN 23-Jun-13 11:30 sklearnex/manifold/tests/test_tsne.py
+-rw-r--r--  2.0 unx      928 b- defN 23-Jun-13 11:30 sklearnex/metrics/__init__.py
+-rw-r--r--  2.0 unx      839 b- defN 23-Jun-13 11:30 sklearnex/metrics/pairwise.py
+-rw-r--r--  2.0 unx      834 b- defN 23-Jun-13 11:30 sklearnex/metrics/ranking.py
+-rw-r--r--  2.0 unx     1592 b- defN 23-Jun-13 11:30 sklearnex/metrics/tests/test_metrics.py
+-rw-r--r--  2.0 unx      863 b- defN 23-Jun-13 11:30 sklearnex/model_selection/__init__.py
+-rw-r--r--  2.0 unx      845 b- defN 23-Jun-13 11:30 sklearnex/model_selection/split.py
+-rw-r--r--  2.0 unx     1277 b- defN 23-Jun-13 11:30 sklearnex/model_selection/tests/test_model_selection.py
+-rw-r--r--  2.0 unx     1086 b- defN 23-Jun-13 11:30 sklearnex/neighbors/__init__.py
+-rw-r--r--  2.0 unx     6105 b- defN 23-Jun-13 11:30 sklearnex/neighbors/common.py
+-rw-r--r--  2.0 unx    14336 b- defN 23-Jun-13 11:30 sklearnex/neighbors/knn_classification.py
+-rw-r--r--  2.0 unx    13361 b- defN 23-Jun-13 11:30 sklearnex/neighbors/knn_regression.py
+-rw-r--r--  2.0 unx    11394 b- defN 23-Jun-13 11:30 sklearnex/neighbors/knn_unsupervised.py
+-rw-r--r--  2.0 unx    14924 b- defN 23-Jun-13 11:30 sklearnex/neighbors/lof.py
+-rw-r--r--  2.0 unx     2203 b- defN 23-Jun-13 11:30 sklearnex/neighbors/tests/test_neighbors.py
+-rw-r--r--  2.0 unx      822 b- defN 23-Jun-13 11:30 sklearnex/preview/__init__.py
+-rw-r--r--  2.0 unx      826 b- defN 23-Jun-13 11:30 sklearnex/preview/decomposition/__init__.py
+-rw-r--r--  2.0 unx    13775 b- defN 23-Jun-13 11:30 sklearnex/preview/decomposition/pca.py
+-rw-r--r--  2.0 unx     1221 b- defN 23-Jun-13 11:30 sklearnex/preview/decomposition/tests/test_preview_pca.py
+-rw-r--r--  2.0 unx     1044 b- defN 23-Jun-13 11:30 sklearnex/preview/ensemble/__init__.py
+-rw-r--r--  2.0 unx    52524 b- defN 23-Jun-13 11:30 sklearnex/preview/ensemble/extra_trees.py
+-rw-r--r--  2.0 unx    47805 b- defN 23-Jun-13 11:30 sklearnex/preview/ensemble/forest.py
+-rw-r--r--  2.0 unx     3101 b- defN 23-Jun-13 11:30 sklearnex/preview/ensemble/tests/test_preview_ensemble.py
+-rw-r--r--  2.0 unx      863 b- defN 23-Jun-13 11:30 sklearnex/preview/linear_model/__init__.py
+-rw-r--r--  2.0 unx     2180 b- defN 23-Jun-13 11:30 sklearnex/preview/linear_model/_common.py
+-rw-r--r--  2.0 unx    11440 b- defN 23-Jun-13 11:30 sklearnex/preview/linear_model/linear.py
+-rw-r--r--  2.0 unx     1525 b- defN 23-Jun-13 11:30 sklearnex/preview/linear_model/tests/test_preview_linear.py
+-rw-r--r--  2.0 unx      833 b- defN 23-Jun-13 11:30 sklearnex/spmd/__init__.py
+-rw-r--r--  2.0 unx      821 b- defN 23-Jun-13 11:30 sklearnex/spmd/basic_statistics/__init__.py
+-rw-r--r--  2.0 unx      886 b- defN 23-Jun-13 11:30 sklearnex/spmd/basic_statistics/basic_statistics.py
+-rw-r--r--  2.0 unx      784 b- defN 23-Jun-13 11:30 sklearnex/spmd/decomposition/__init__.py
+-rw-r--r--  2.0 unx      871 b- defN 23-Jun-13 11:30 sklearnex/spmd/decomposition/pca.py
+-rw-r--r--  2.0 unx      873 b- defN 23-Jun-13 11:30 sklearnex/spmd/ensemble/__init__.py
+-rw-r--r--  2.0 unx     3103 b- defN 23-Jun-13 11:30 sklearnex/spmd/ensemble/forest.py
+-rw-r--r--  2.0 unx      819 b- defN 23-Jun-13 11:30 sklearnex/spmd/linear_model/__init__.py
+-rw-r--r--  2.0 unx      883 b- defN 23-Jun-13 11:30 sklearnex/spmd/linear_model/linear_model.py
+-rw-r--r--  2.0 unx      906 b- defN 23-Jun-13 11:30 sklearnex/spmd/neighbors/__init__.py
+-rw-r--r--  2.0 unx      939 b- defN 23-Jun-13 11:30 sklearnex/spmd/neighbors/neighbors.py
+-rw-r--r--  2.0 unx     1076 b- defN 23-Jun-13 11:30 sklearnex/svm/__init__.py
+-rw-r--r--  2.0 unx     7489 b- defN 23-Jun-13 11:30 sklearnex/svm/_common.py
+-rw-r--r--  2.0 unx     7963 b- defN 23-Jun-13 11:30 sklearnex/svm/nusvc.py
+-rw-r--r--  2.0 unx     4774 b- defN 23-Jun-13 11:30 sklearnex/svm/nusvr.py
+-rw-r--r--  2.0 unx     9284 b- defN 23-Jun-13 11:30 sklearnex/svm/svc.py
+-rw-r--r--  2.0 unx     4778 b- defN 23-Jun-13 11:30 sklearnex/svm/svr.py
+-rw-r--r--  2.0 unx     2626 b- defN 23-Jun-13 11:30 sklearnex/svm/tests/test_svm.py
+-rw-r--r--  2.0 unx     4683 b- defN 23-Jun-13 11:30 sklearnex/tests/_models_info.py
+-rw-r--r--  2.0 unx     1407 b- defN 23-Jun-13 11:30 sklearnex/tests/test_config.py
+-rw-r--r--  2.0 unx     7883 b- defN 23-Jun-13 11:30 sklearnex/tests/test_memory_usage.py
+-rw-r--r--  2.0 unx     7523 b- defN 23-Jun-13 11:30 sklearnex/tests/test_monkeypatch.py
+-rw-r--r--  2.0 unx     3737 b- defN 23-Jun-13 11:30 sklearnex/tests/test_patching.py
+-rw-r--r--  2.0 unx    14286 b- defN 23-Jun-13 11:30 sklearnex/tests/test_run_to_run_stability_tests.py
+-rw-r--r--  2.0 unx     3778 b- defN 23-Jun-13 11:30 sklearnex/tests/utils/_launch_algorithms.py
+-rw-r--r--  2.0 unx      840 b- defN 23-Jun-13 11:30 sklearnex/utils/__init__.py
+-rw-r--r--  2.0 unx      848 b- defN 23-Jun-13 11:30 sklearnex/utils/validation.py
+-rw-rw-rw-  2.0 unx    10797 b- defN 23-Jun-30 18:20 scikit_learn_intelex-2023.2.0.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    12375 b- defN 23-Jun-30 18:20 scikit_learn_intelex-2023.2.0.dist-info/METADATA
+-rw-r--r--  2.0 unx      143 b- defN 23-Jun-30 18:20 scikit_learn_intelex-2023.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Jun-30 18:20 scikit_learn_intelex-2023.2.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     8238 b- defN 23-Jun-30 18:20 scikit_learn_intelex-2023.2.0.dist-info/RECORD
+90 files, 413326 bytes uncompressed, 111246 bytes compressed:  73.1%
```

## zipnote {}

```diff
@@ -1,265 +1,271 @@
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/__init__.py
+Filename: sklearnex/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/__main__.py
+Filename: sklearnex/__main__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_config.py
+Filename: sklearnex/_config.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_device_offload.py
+Filename: sklearnex/_device_offload.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_utils.py
+Filename: sklearnex/_utils.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/dispatcher.py
+Filename: sklearnex/dispatcher.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/basic_statistics/__init__.py
+Filename: sklearnex/basic_statistics/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/basic_statistics/basic_statistics.py
+Filename: sklearnex/basic_statistics/basic_statistics.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/__init__.py
+Filename: sklearnex/cluster/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/dbscan.py
+Filename: sklearnex/cluster/dbscan.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/k_means.py
+Filename: sklearnex/cluster/k_means.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/tests/test_dbscan.py
+Filename: sklearnex/cluster/tests/test_dbscan.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/tests/test_kmeans.py
+Filename: sklearnex/cluster/tests/test_kmeans.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/__init__.py
+Filename: sklearnex/decomposition/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/pca.py
+Filename: sklearnex/decomposition/pca.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/tests/test_pca.py
+Filename: sklearnex/decomposition/tests/test_pca.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/doc/third-party-programs.txt
+Filename: sklearnex/doc/third-party-programs.txt
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/__init__.py
+Filename: sklearnex/ensemble/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/forest.py
+Filename: sklearnex/ensemble/forest.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/tests/test_random_forest.py
+Filename: sklearnex/ensemble/tests/test_forest.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/glob/__main__.py
+Filename: sklearnex/glob/__main__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/glob/dispatcher.py
+Filename: sklearnex/glob/dispatcher.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/__init__.py
+Filename: sklearnex/linear_model/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/coordinate_descent.py
+Filename: sklearnex/linear_model/coordinate_descent.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/linear.py
+Filename: sklearnex/linear_model/linear.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/logistic_path.py
+Filename: sklearnex/linear_model/logistic_path.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/ridge.py
+Filename: sklearnex/linear_model/ridge.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/tests/test_linear.py
+Filename: sklearnex/linear_model/tests/test_linear.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/tests/test_logreg.py
+Filename: sklearnex/linear_model/tests/test_logreg.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/__init__.py
+Filename: sklearnex/manifold/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/t_sne.py
+Filename: sklearnex/manifold/t_sne.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/tests/test_tsne.py
+Filename: sklearnex/manifold/tests/test_tsne.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/__init__.py
+Filename: sklearnex/metrics/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/pairwise.py
+Filename: sklearnex/metrics/pairwise.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/ranking.py
+Filename: sklearnex/metrics/ranking.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/tests/test_metrics.py
+Filename: sklearnex/metrics/tests/test_metrics.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/__init__.py
+Filename: sklearnex/model_selection/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/split.py
+Filename: sklearnex/model_selection/split.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/tests/test_model_selection.py
+Filename: sklearnex/model_selection/tests/test_model_selection.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/__init__.py
+Filename: sklearnex/neighbors/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_classification.py
+Filename: sklearnex/neighbors/common.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_regression.py
+Filename: sklearnex/neighbors/knn_classification.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_unsupervised.py
+Filename: sklearnex/neighbors/knn_regression.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/lof.py
+Filename: sklearnex/neighbors/knn_unsupervised.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/tests/test_neighbors.py
+Filename: sklearnex/neighbors/lof.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/__init__.py
+Filename: sklearnex/neighbors/tests/test_neighbors.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/__init__.py
+Filename: sklearnex/preview/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/pca.py
+Filename: sklearnex/preview/decomposition/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/tests/test_preview_pca.py
+Filename: sklearnex/preview/decomposition/pca.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/__init__.py
+Filename: sklearnex/preview/decomposition/tests/test_preview_pca.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/forest.py
+Filename: sklearnex/preview/ensemble/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/tests/test_random_preview_forest.py
+Filename: sklearnex/preview/ensemble/extra_trees.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/__init__.py
+Filename: sklearnex/preview/ensemble/forest.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/_common.py
+Filename: sklearnex/preview/ensemble/tests/test_preview_ensemble.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/linear.py
+Filename: sklearnex/preview/linear_model/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/tests/test_preview_linear.py
+Filename: sklearnex/preview/linear_model/_common.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/__init__.py
+Filename: sklearnex/preview/linear_model/linear.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/basic_statistics/__init__.py
+Filename: sklearnex/preview/linear_model/tests/test_preview_linear.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/basic_statistics/basic_statistics.py
+Filename: sklearnex/spmd/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/decomposition/__init__.py
+Filename: sklearnex/spmd/basic_statistics/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/decomposition/pca.py
+Filename: sklearnex/spmd/basic_statistics/basic_statistics.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/ensemble/__init__.py
+Filename: sklearnex/spmd/decomposition/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/ensemble/forest.py
+Filename: sklearnex/spmd/decomposition/pca.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/linear_model/__init__.py
+Filename: sklearnex/spmd/ensemble/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/linear_model/linear_model.py
+Filename: sklearnex/spmd/ensemble/forest.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/neighbors/__init__.py
+Filename: sklearnex/spmd/linear_model/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/neighbors/neighbors.py
+Filename: sklearnex/spmd/linear_model/linear_model.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/__init__.py
+Filename: sklearnex/spmd/neighbors/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/_common.py
+Filename: sklearnex/spmd/neighbors/neighbors.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/nusvc.py
+Filename: sklearnex/svm/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/nusvr.py
+Filename: sklearnex/svm/_common.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/svc.py
+Filename: sklearnex/svm/nusvc.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/svr.py
+Filename: sklearnex/svm/nusvr.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/tests/test_svm.py
+Filename: sklearnex/svm/svc.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/_models_info.py
+Filename: sklearnex/svm/svr.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_config.py
+Filename: sklearnex/svm/tests/test_svm.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_memory_usage.py
+Filename: sklearnex/tests/_models_info.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_monkeypatch.py
+Filename: sklearnex/tests/test_config.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_patching.py
+Filename: sklearnex/tests/test_memory_usage.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_run_to_run_stability_tests.py
+Filename: sklearnex/tests/test_monkeypatch.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/utils/_launch_algorithms.py
+Filename: sklearnex/tests/test_patching.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/utils/__init__.py
+Filename: sklearnex/tests/test_run_to_run_stability_tests.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/utils/validation.py
+Filename: sklearnex/tests/utils/_launch_algorithms.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.dist-info/LICENSE.txt
+Filename: sklearnex/utils/__init__.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.dist-info/METADATA
+Filename: sklearnex/utils/validation.py
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.dist-info/WHEEL
+Filename: scikit_learn_intelex-2023.2.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.dist-info/top_level.txt
+Filename: scikit_learn_intelex-2023.2.0.dist-info/METADATA
 Comment: 
 
-Filename: scikit_learn_intelex-2023.1.1.dist-info/RECORD
+Filename: scikit_learn_intelex-2023.2.0.dist-info/WHEEL
+Comment: 
+
+Filename: scikit_learn_intelex-2023.2.0.dist-info/top_level.txt
+Comment: 
+
+Filename: scikit_learn_intelex-2023.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/__init__.py` & `sklearnex/cluster/tests/test_kmeans.py`

 * *Files 26% similar despite different names*

```diff
@@ -11,29 +11,21 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from .dispatcher import patch_sklearn
-from .dispatcher import unpatch_sklearn
-from .dispatcher import get_patch_names
-from .dispatcher import get_patch_map
-from .dispatcher import sklearn_is_patched
-from ._config import get_config, set_config, config_context
+import numpy as np
+from numpy.testing import assert_allclose
 
-__all__ = [
-    'cluster', 'config_context', 'basic_statistics', 'decomposition', 'ensemble',
-    'get_config', 'get_patch_names', 'linear_model', 'manifold', 'metrics',
-    'neighbors', 'patch_sklearn', 'set_config', 'svm', 'unpatch_sklearn',
-    'utils', 'sklearn_is_patchedget_patch_map'
-]
 
-from onedal import _is_dpc_backend
-
-if _is_dpc_backend:
-    __all__.append('spmd')
-
-from ._utils import set_sklearn_ex_verbose
-
-set_sklearn_ex_verbose()
+def test_sklearnex_import():
+    from sklearnex.cluster import KMeans
+    X = np.array([[1, 2], [1, 4], [1, 0],
+                  [10, 2], [10, 4], [10, 0]])
+    kmeans = KMeans(n_clusters=2, random_state=0).fit(X)
+    assert 'daal4py' in kmeans.__module__
+
+    result = kmeans.predict([[0, 0], [12, 3]])
+    expected = np.array([1, 0], dtype=np.int32)
+    assert_allclose(expected, result)
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/__main__.py` & `sklearnex/__main__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_config.py` & `sklearnex/_config.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_device_offload.py` & `sklearnex/_device_offload.py`

 * *Files 1% similar despite different names*

```diff
@@ -44,15 +44,14 @@
             self.is_cpu = 'cpu' in filter_string
             self.is_gpu = 'gpu' in filter_string
             # TODO: check for possibility of fp64 support
             # on other devices in this dummy class
             self.has_aspect_fp64 = self.is_cpu
 
             if not (self.is_cpu):
-                import logging
                 logging.warning("Device support is limited. "
                                 "Please install dpctl for full experience")
 
         def get_filter_string(self):
             return self._filter_string
 
     def __init__(self, filter_string):
@@ -154,20 +153,20 @@
     q = _get_global_queue()
     q, hostargs = _transfer_to_host(q, *args)
     q, hostvalues = _transfer_to_host(q, *kwargs.values())
     hostkwargs = dict(zip(kwargs.keys(), hostvalues))
 
     backend, q, cpu_fallback = _get_backend(obj, q, method_name, *hostargs)
 
-    logging.info(f"sklearn.{method_name}: {get_patch_message(backend, q, cpu_fallback)}")
     if backend == 'onedal':
         return branches[backend](obj, *hostargs, **hostkwargs, queue=q)
     if backend == 'sklearn':
         return branches[backend](obj, *hostargs, **hostkwargs)
-    raise RuntimeError(f'Undefined backend {backend} in {method_name}')
+    raise RuntimeError(f'Undefined backend {backend} in '
+                       f'{obj.__class__.__name__}.{method_name}')
 
 
 def _copy_to_usm(queue, array):
     if not dpctl_available:
         raise RuntimeError("dpctl need to be installed to work "
                            "with __sycl_usm_array_interface__")
     mem = MemoryUSMDevice(array.nbytes, queue=queue)
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/_utils.py` & `sklearnex/_utils.py`

 * *Files 20% similar despite different names*

```diff
@@ -11,33 +11,40 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
+import logging
+import warnings
+import os
+import sys
+from daal4py.sklearn._utils import daal_check_version
+
+
 def set_sklearn_ex_verbose():
-    import logging
-    import warnings
-    import os
-    import sys
-    logLevel = os.environ.get("SKLEARNEX_VERBOSE")
+    log_level = os.environ.get("SKLEARNEX_VERBOSE")
+
+    logger = logging.getLogger('sklearnex')
+    logging_channel = logging.StreamHandler()
+    logging_formatter = logging.Formatter('%(levelname)s:%(name)s: %(message)s')
+    logging_channel.setFormatter(logging_formatter)
+    logger.addHandler(logging_channel)
+
     try:
-        if logLevel is not None:
-            logging.basicConfig(
-                stream=sys.stdout,
-                format='SKLEARNEX %(levelname)s: %(message)s', level=logLevel.upper())
+        if log_level is not None:
+            logger.setLevel(log_level)
     except Exception:
         warnings.warn('Unknown level "{}" for logging.\n'
                       'Please, use one of "CRITICAL", "ERROR", '
-                      '"WARNING", "INFO", "DEBUG".'.format(logLevel))
+                      '"WARNING", "INFO", "DEBUG".'.format(log_level))
 
 
 def get_patch_message(s, queue=None, cpu_fallback=False):
-    import sys
     if s == "onedal":
         message = "running accelerated version on "
         if queue is not None:
             if queue.sycl_device.is_gpu:
                 message += 'GPU'
             elif queue.sycl_device.is_cpu:
                 message += 'CPU'
@@ -68,9 +75,8 @@
         raise ValueError(
             f"Invalid input - expected one of 'onedal','sklearn',"
             f" 'sklearn_after_onedal', got {s}")
     return message
 
 
 def get_sklearnex_version(rule):
-    from daal4py.sklearn._utils import daal_check_version
     return daal_check_version(rule)
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/dispatcher.py` & `sklearnex/dispatcher.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,225 +1,281 @@
-#!/usr/bin/env python
-#===============================================================================
-# Copyright 2021 Intel Corporation
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# ===============================================================================
-
-# Other imports
-import sys
-import os
-from functools import lru_cache
-from daal4py.sklearn._utils import daal_check_version, sklearn_check_version
-
-
-def _is_new_patching_available():
-    return os.environ.get('OFF_ONEDAL_IFACE') is None \
-        and daal_check_version((2021, 'P', 300))
-
-
-def _is_preview_enabled():
-    return os.environ.get('SKLEARNEX_PREVIEW') is not None
-
-
-@lru_cache(maxsize=None)
-def get_patch_map():
-    from daal4py.sklearn.monkeypatch.dispatcher import _get_map_of_algorithms
-    mapping = _get_map_of_algorithms().copy()
-
-    if _is_new_patching_available():
-        # Classes for patching
-
-        from ._config import set_config as set_config_sklearnex
-        from ._config import get_config as get_config_sklearnex
-        from ._config import config_context as config_context_sklearnex
-
-        from .svm import SVR as SVR_sklearnex
-        from .svm import SVC as SVC_sklearnex
-        from .svm import NuSVR as NuSVR_sklearnex
-        from .svm import NuSVC as NuSVC_sklearnex
-
-        from .neighbors import KNeighborsClassifier as KNeighborsClassifier_sklearnex
-        from .neighbors import KNeighborsRegressor as KNeighborsRegressor_sklearnex
-        from .neighbors import NearestNeighbors as NearestNeighbors_sklearnex
-        from .neighbors import LocalOutlierFactor as LocalOutlierFactor_sklearnex
-
-        # Preview classes for patching
-
-        from .preview.decomposition import PCA as PCA_sklearnex
-
-        from .preview.linear_model import LinearRegression as LinearRegression_sklearnex
-
-        from .preview.ensemble import RandomForestClassifier \
-            as RandomForestClassifier_sklearnex
-        from .preview.ensemble import RandomForestRegressor \
-            as RandomForestRegressor_sklearnex
-
-        # Scikit-learn* modules
-
-        import sklearn as base_module
-        import sklearn.ensemble as ensemble_module
-        import sklearn.decomposition as decomposition_module
-        import sklearn.svm as svm_module
-        import sklearn.neighbors as neighbors_module
-        import sklearn.linear_model as linear_model_module
-
-        # Patch for mapping
-        # Algorithms
-
-        if _is_preview_enabled():
-            # Ensemble
-            mapping.pop('random_forest_classifier')
-            mapping.pop('random_forest_regressor')
-            mapping.pop('randomrorestclassifier')
-            mapping.pop('randomforestregressor')
-            mapping['random_forest_classifier'] = [[(ensemble_module,
-                                                     'RandomForestClassifier',
-                                                     RandomForestClassifier_sklearnex),
-                                                    None]]
-            mapping['random_forest_regressor'] = [[(ensemble_module,
-                                                    'RandomForestRegressor',
-                                                    RandomForestRegressor_sklearnex),
-                                                   None]]
-            mapping['randomrorestclassifier'] = mapping['random_forest_classifier']
-            mapping['randomforestregressor'] = mapping['random_forest_regressor']
-
-            # PCA
-            mapping.pop('pca')
-            mapping['pca'] = [[(decomposition_module, 'PCA', PCA_sklearnex), None]]
-
-            # Linear Regression
-            mapping.pop('linear')
-            mapping['linear'] = [[(linear_model_module,
-                                   'LinearRegression',
-                                   LinearRegression_sklearnex), None]]
-
-        # SVM
-        mapping.pop('svm')
-        mapping.pop('svc')
-        mapping['svr'] = [[(svm_module, 'SVR', SVR_sklearnex), None]]
-        mapping['svc'] = [[(svm_module, 'SVC', SVC_sklearnex), None]]
-        mapping['nusvr'] = [[(svm_module, 'NuSVR', NuSVR_sklearnex), None]]
-        mapping['nusvc'] = [[(svm_module, 'NuSVC', NuSVC_sklearnex), None]]
-
-        # kNN
-        mapping.pop('knn_classifier')
-        mapping.pop('kneighborsclassifier')
-        mapping.pop('knn_regressor')
-        mapping.pop('kneighborsregressor')
-        mapping.pop('nearest_neighbors')
-        mapping.pop('nearestneighbors')
-        mapping['knn_classifier'] = [[(neighbors_module,
-                                       'KNeighborsClassifier',
-                                       KNeighborsClassifier_sklearnex), None]]
-        mapping['knn_regressor'] = [[(neighbors_module,
-                                      'KNeighborsRegressor',
-                                      KNeighborsRegressor_sklearnex), None]]
-        mapping['nearest_neighbors'] = [[(neighbors_module,
-                                          'NearestNeighbors',
-                                          NearestNeighbors_sklearnex), None]]
-        mapping['kneighborsclassifier'] = mapping['knn_classifier']
-        mapping['kneighborsregressor'] = mapping['knn_regressor']
-        mapping['nearestneighbors'] = mapping['nearest_neighbors']
-
-        # LocalOutlierFactor
-        mapping['lof'] = [[(neighbors_module,
-                            'LocalOutlierFactor',
-                            LocalOutlierFactor_sklearnex), None]]
-        mapping['localoutlierfactor'] = mapping['lof']
-
-        # Configs
-        mapping['set_config'] = [[(base_module,
-                                   'set_config',
-                                   set_config_sklearnex), None]]
-        mapping['get_config'] = [[(base_module,
-                                   'get_config',
-                                   get_config_sklearnex), None]]
-        mapping['config_context'] = [[(base_module,
-                                      'config_context',
-                                       config_context_sklearnex), None]]
-    return mapping
-
-
-def get_patch_names():
-    return list(get_patch_map().keys())
-
-
-def patch_sklearn(name=None, verbose=True, global_patch=False, preview=False):
-    if preview:
-        os.environ['SKLEARNEX_PREVIEW'] = 'enabled_via_patch_sklearn'
-    if not sklearn_check_version('0.22'):
-        raise NotImplementedError(
-            "Intel(R) Extension for Scikit-learn* patches apply "
-            "for scikit-learn >= 0.22 only ...")
-
-    if global_patch:
-        from sklearnex.glob.dispatcher import patch_sklearn_global
-        patch_sklearn_global(name, verbose)
-
-    from daal4py.sklearn import patch_sklearn as patch_sklearn_orig
-
-    if _is_new_patching_available():
-        for config in ['set_config', 'get_config', 'config_context']:
-            patch_sklearn_orig(config, verbose=False, deprecation=False,
-                               get_map=get_patch_map)
-    if isinstance(name, list):
-        for algorithm in name:
-            patch_sklearn_orig(algorithm, verbose=False, deprecation=False,
-                               get_map=get_patch_map)
-    else:
-        patch_sklearn_orig(name, verbose=False, deprecation=False,
-                           get_map=get_patch_map)
-
-    if verbose and sys.stderr is not None:
-        sys.stderr.write(
-            "Intel(R) Extension for Scikit-learn* enabled "
-            "(https://github.com/intel/scikit-learn-intelex)\n")
-
-
-def unpatch_sklearn(name=None, global_unpatch=False):
-    if global_unpatch:
-        from sklearnex.glob.dispatcher import unpatch_sklearn_global
-        unpatch_sklearn_global()
-    from daal4py.sklearn import unpatch_sklearn as unpatch_sklearn_orig
-
-    if isinstance(name, list):
-        for algorithm in name:
-            unpatch_sklearn_orig(algorithm, get_map=get_patch_map)
-    else:
-        if _is_new_patching_available():
-            for config in ['set_config', 'get_config', 'config_context']:
-                unpatch_sklearn_orig(config, get_map=get_patch_map)
-        unpatch_sklearn_orig(name, get_map=get_patch_map)
-    if os.environ.get('SKLEARNEX_PREVIEW') == 'enabled_via_patch_sklearn':
-        os.environ.pop('SKLEARNEX_PREVIEW')
-
-
-def sklearn_is_patched(name=None, return_map=False):
-    from daal4py.sklearn import sklearn_is_patched as sklearn_is_patched_orig
-
-    if isinstance(name, list):
-        if return_map:
-            result = {}
-            for algorithm in name:
-                result[algorithm] = sklearn_is_patched_orig(
-                    algorithm, get_map=get_patch_map)
-            return result
-        else:
-            is_patched = True
-            for algorithm in name:
-                is_patched = is_patched and \
-                    sklearn_is_patched_orig(algorithm, get_map=get_patch_map)
-            return is_patched
-    else:
-        return sklearn_is_patched_orig(
-            name, get_map=get_patch_map, return_map=return_map)
+#!/usr/bin/env python
+# ===============================================================================
+# Copyright 2021 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# ===============================================================================
+
+import os
+import sys
+from functools import lru_cache
+
+from daal4py.sklearn._utils import daal_check_version, sklearn_check_version
+
+
+def _is_new_patching_available():
+    return os.environ.get("OFF_ONEDAL_IFACE") is None and daal_check_version(
+        (2021, "P", 300)
+    )
+
+
+def _is_preview_enabled():
+    return os.environ.get("SKLEARNEX_PREVIEW") is not None
+
+
+@lru_cache(maxsize=None)
+def get_patch_map():
+    from daal4py.sklearn.monkeypatch.dispatcher import _get_map_of_algorithms
+
+    mapping = _get_map_of_algorithms().copy()
+
+    if _is_new_patching_available():
+        # Scikit-learn* modules
+        import sklearn as base_module
+        import sklearn.decomposition as decomposition_module
+        import sklearn.ensemble as ensemble_module
+        import sklearn.linear_model as linear_model_module
+        import sklearn.neighbors as neighbors_module
+        import sklearn.svm as svm_module
+
+        # Classes and functions for patching
+        from ._config import config_context as config_context_sklearnex
+        from ._config import get_config as get_config_sklearnex
+        from ._config import set_config as set_config_sklearnex
+        from .neighbors import KNeighborsClassifier as KNeighborsClassifier_sklearnex
+        from .neighbors import KNeighborsRegressor as KNeighborsRegressor_sklearnex
+        from .neighbors import LocalOutlierFactor as LocalOutlierFactor_sklearnex
+        from .neighbors import NearestNeighbors as NearestNeighbors_sklearnex
+        from .svm import SVC as SVC_sklearnex
+        from .svm import SVR as SVR_sklearnex
+        from .svm import NuSVC as NuSVC_sklearnex
+        from .svm import NuSVR as NuSVR_sklearnex
+
+        # Preview classes for patching
+        from .preview.decomposition import PCA as PCA_sklearnex
+        from .preview.linear_model import LinearRegression as LinearRegression_sklearnex
+        from .preview.ensemble import (
+            ExtraTreesClassifier as ExtraTreesClassifier_sklearnex,
+            ExtraTreesRegressor as ExtraTreesRegressor_sklearnex,
+            RandomForestClassifier as RandomForestClassifier_sklearnex,
+            RandomForestRegressor as RandomForestRegressor_sklearnex,
+        )
+
+        # Patch for mapping
+        if _is_preview_enabled():
+            # Ensemble
+            mapping["extra_trees_classifier"] = [[(ensemble_module,
+                                                   "ExtraTreesClassifier",
+                                                   ExtraTreesClassifier_sklearnex),
+                                                  None]]
+            mapping["extra_trees_regressor"] = [[(ensemble_module,
+                                                  "ExtraTreesRegressor",
+                                                  ExtraTreesRegressor_sklearnex),
+                                                 None]]
+
+            mapping.pop("random_forest_classifier")
+            mapping.pop("random_forest_regressor")
+            mapping.pop("randomrorestclassifier")
+            mapping.pop("randomforestregressor")
+            mapping["random_forest_classifier"] = [
+                [
+                    (
+                        ensemble_module,
+                        "RandomForestClassifier",
+                        RandomForestClassifier_sklearnex,
+                    ),
+                    None,
+                ]
+            ]
+            mapping["random_forest_regressor"] = [
+                [
+                    (
+                        ensemble_module,
+                        "RandomForestRegressor",
+                        RandomForestRegressor_sklearnex,
+                    ),
+                    None,
+                ]
+            ]
+            mapping["randomforestclassifier"] = mapping["random_forest_classifier"]
+            mapping["randomforestregressor"] = mapping["random_forest_regressor"]
+
+            # PCA
+            mapping.pop("pca")
+            mapping["pca"] = [[(decomposition_module, "PCA", PCA_sklearnex), None]]
+
+            # Linear Regression
+            mapping.pop("linear")
+            mapping["linear"] = [
+                [
+                    (
+                        linear_model_module,
+                        "LinearRegression",
+                        LinearRegression_sklearnex,
+                    ),
+                    None,
+                ]
+            ]
+
+        # SVM
+        mapping.pop("svm")
+        mapping.pop("svc")
+        mapping["svr"] = [[(svm_module, "SVR", SVR_sklearnex), None]]
+        mapping["svc"] = [[(svm_module, "SVC", SVC_sklearnex), None]]
+        mapping["nusvr"] = [[(svm_module, "NuSVR", NuSVR_sklearnex), None]]
+        mapping["nusvc"] = [[(svm_module, "NuSVC", NuSVC_sklearnex), None]]
+
+        # kNN
+        mapping.pop("knn_classifier")
+        mapping.pop("kneighborsclassifier")
+        mapping.pop("knn_regressor")
+        mapping.pop("kneighborsregressor")
+        mapping.pop("nearest_neighbors")
+        mapping.pop("nearestneighbors")
+        mapping["knn_classifier"] = [
+            [
+                (
+                    neighbors_module,
+                    "KNeighborsClassifier",
+                    KNeighborsClassifier_sklearnex,
+                ),
+                None,
+            ]
+        ]
+        mapping["knn_regressor"] = [
+            [
+                (
+                    neighbors_module,
+                    "KNeighborsRegressor",
+                    KNeighborsRegressor_sklearnex,
+                ),
+                None,
+            ]
+        ]
+        mapping["nearest_neighbors"] = [
+            [(neighbors_module, "NearestNeighbors", NearestNeighbors_sklearnex), None]
+        ]
+        mapping["kneighborsclassifier"] = mapping["knn_classifier"]
+        mapping["kneighborsregressor"] = mapping["knn_regressor"]
+        mapping["nearestneighbors"] = mapping["nearest_neighbors"]
+
+        # LocalOutlierFactor
+        mapping["lof"] = [
+            [
+                (neighbors_module, "LocalOutlierFactor", LocalOutlierFactor_sklearnex),
+                None,
+            ]
+        ]
+        mapping["localoutlierfactor"] = mapping["lof"]
+
+        # Configs
+        mapping["set_config"] = [
+            [(base_module, "set_config", set_config_sklearnex), None]
+        ]
+        mapping["get_config"] = [
+            [(base_module, "get_config", get_config_sklearnex), None]
+        ]
+        mapping["config_context"] = [
+            [(base_module, "config_context", config_context_sklearnex), None]
+        ]
+    return mapping
+
+
+def get_patch_names():
+    return list(get_patch_map().keys())
+
+
+def patch_sklearn(name=None, verbose=True, global_patch=False, preview=False):
+    if preview:
+        os.environ["SKLEARNEX_PREVIEW"] = "enabled_via_patch_sklearn"
+    if not sklearn_check_version("0.22"):
+        raise NotImplementedError(
+            "Intel(R) Extension for Scikit-learn* patches apply "
+            "for scikit-learn >= 0.22 only ..."
+        )
+
+    if global_patch:
+        from sklearnex.glob.dispatcher import patch_sklearn_global
+
+        patch_sklearn_global(name, verbose)
+
+    from daal4py.sklearn import patch_sklearn as patch_sklearn_orig
+
+    if _is_new_patching_available():
+        for config in ["set_config", "get_config", "config_context"]:
+            patch_sklearn_orig(
+                config, verbose=False, deprecation=False, get_map=get_patch_map
+            )
+    if isinstance(name, list):
+        for algorithm in name:
+            patch_sklearn_orig(
+                algorithm, verbose=False, deprecation=False, get_map=get_patch_map
+            )
+    else:
+        patch_sklearn_orig(
+            name, verbose=False, deprecation=False, get_map=get_patch_map
+        )
+
+    if verbose and sys.stderr is not None:
+        sys.stderr.write(
+            "Intel(R) Extension for Scikit-learn* enabled "
+            "(https://github.com/intel/scikit-learn-intelex)\n"
+        )
+
+
+def unpatch_sklearn(name=None, global_unpatch=False):
+    if global_unpatch:
+        from sklearnex.glob.dispatcher import unpatch_sklearn_global
+
+        unpatch_sklearn_global()
+    from daal4py.sklearn import unpatch_sklearn as unpatch_sklearn_orig
+
+    if isinstance(name, list):
+        for algorithm in name:
+            unpatch_sklearn_orig(algorithm, get_map=get_patch_map)
+    else:
+        if _is_new_patching_available():
+            for config in ["set_config", "get_config", "config_context"]:
+                unpatch_sklearn_orig(config, get_map=get_patch_map)
+        unpatch_sklearn_orig(name, get_map=get_patch_map)
+    if os.environ.get("SKLEARNEX_PREVIEW") == "enabled_via_patch_sklearn":
+        os.environ.pop("SKLEARNEX_PREVIEW")
+
+
+def sklearn_is_patched(name=None, return_map=False):
+    from daal4py.sklearn import sklearn_is_patched as sklearn_is_patched_orig
+
+    if isinstance(name, list):
+        if return_map:
+            result = {}
+            for algorithm in name:
+                result[algorithm] = sklearn_is_patched_orig(
+                    algorithm, get_map=get_patch_map
+                )
+            return result
+        else:
+            is_patched = True
+            for algorithm in name:
+                is_patched = is_patched and sklearn_is_patched_orig(
+                    algorithm, get_map=get_patch_map
+                )
+            return is_patched
+    else:
+        return sklearn_is_patched_orig(
+            name, get_map=get_patch_map, return_map=return_map
+        )
+
+
+def is_patched_instance(instance: object) -> bool:
+    """Returns True if the `instance` is patched with scikit-learn-intelex"""
+    module = getattr(instance, "__module__", "")
+    return ("daal4py" in module) or ("sklearnex" in module)
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/basic_statistics/__init__.py` & `sklearnex/basic_statistics/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/basic_statistics/basic_statistics.py` & `sklearnex/basic_statistics/basic_statistics.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/__init__.py` & `sklearnex/cluster/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/dbscan.py` & `sklearnex/cluster/dbscan.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/k_means.py` & `sklearnex/cluster/k_means.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/tests/test_dbscan.py` & `sklearnex/cluster/tests/test_dbscan.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/cluster/tests/test_kmeans.py` & `sklearnex/preview/decomposition/tests/test_preview_pca.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 #===============================================================================
-# Copyright 2021 Intel Corporation
+# Copyright 2023 Intel Corporation
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
@@ -16,16 +16,13 @@
 #===============================================================================
 
 import numpy as np
 from numpy.testing import assert_allclose
 
 
 def test_sklearnex_import():
-    from sklearnex.cluster import KMeans
-    X = np.array([[1, 2], [1, 4], [1, 0],
-                  [10, 2], [10, 4], [10, 0]])
-    kmeans = KMeans(n_clusters=2, random_state=0).fit(X)
-    assert 'daal4py' in kmeans.__module__
-
-    result = kmeans.predict([[0, 0], [12, 3]])
-    expected = np.array([1, 0], dtype=np.int32)
-    assert_allclose(expected, result)
+    from sklearnex.preview.decomposition import PCA
+    X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])
+    pca = PCA(n_components=2, svd_solver='full').fit(X)
+    assert 'sklearnex' in pca.__module__
+    assert hasattr(pca, '_onedal_estimator')
+    assert_allclose(pca.singular_values_, [6.30061232, 0.54980396])
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/__init__.py` & `sklearnex/decomposition/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/pca.py` & `sklearnex/decomposition/pca.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/decomposition/tests/test_pca.py` & `sklearnex/decomposition/tests/test_pca.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/doc/third-party-programs.txt` & `sklearnex/doc/third-party-programs.txt`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/__init__.py` & `sklearnex/ensemble/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/forest.py` & `sklearnex/ensemble/forest.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/ensemble/tests/test_random_forest.py` & `sklearnex/ensemble/tests/test_forest.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/glob/__main__.py` & `sklearnex/glob/__main__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/glob/dispatcher.py` & `sklearnex/glob/dispatcher.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/__init__.py` & `sklearnex/linear_model/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/coordinate_descent.py` & `sklearnex/linear_model/coordinate_descent.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/linear.py` & `sklearnex/linear_model/linear.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/logistic_path.py` & `sklearnex/linear_model/logistic_path.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/ridge.py` & `sklearnex/linear_model/ridge.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/tests/test_linear.py` & `sklearnex/linear_model/tests/test_linear.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/linear_model/tests/test_logreg.py` & `sklearnex/linear_model/tests/test_logreg.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/__init__.py` & `sklearnex/manifold/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/t_sne.py` & `sklearnex/manifold/t_sne.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/manifold/tests/test_tsne.py` & `sklearnex/manifold/tests/test_tsne.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/__init__.py` & `sklearnex/metrics/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/pairwise.py` & `sklearnex/metrics/pairwise.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,8 +11,8 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from daal4py.sklearn.metrics import daal_pairwise_distances as pairwise_distances
+from daal4py.sklearn.metrics import pairwise_distances
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/ranking.py` & `sklearnex/utils/validation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 #!/usr/bin/env python
 #===============================================================================
-# Copyright 2021 Intel Corporation
+# Copyright 2022 Intel Corporation
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from daal4py.sklearn.metrics import _daal_roc_auc_score as roc_auc_score
+from daal4py.sklearn.utils.validation import _assert_all_finite
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/metrics/tests/test_metrics.py` & `sklearnex/metrics/tests/test_metrics.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/__init__.py` & `sklearnex/model_selection/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/split.py` & `sklearnex/model_selection/split.py`

 * *Files 11% similar despite different names*

```diff
@@ -11,8 +11,8 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from daal4py.sklearn.model_selection import _daal_train_test_split as train_test_split
+from daal4py.sklearn.model_selection import train_test_split
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/model_selection/tests/test_model_selection.py` & `sklearnex/model_selection/tests/test_model_selection.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/__init__.py` & `sklearnex/neighbors/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_classification.py` & `sklearnex/neighbors/knn_classification.py`

 * *Files 17% similar despite different names*

```diff
@@ -29,17 +29,17 @@
 from sklearn.neighbors._unsupervised import NearestNeighbors as \
     sklearn_NearestNeighbors
 from sklearn.utils.validation import _deprecate_positional_args, check_is_fitted
 
 from onedal.datatypes import _check_array, _num_features, _num_samples
 from onedal.neighbors import KNeighborsClassifier as onedal_KNeighborsClassifier
 
+from .common import KNeighborsDispatchingBase
 from .._device_offload import dispatch, wrap_output_data
 import numpy as np
-from scipy import sparse as sp
 
 
 if sklearn_check_version("0.24"):
     class KNeighborsClassifier_(sklearn_KNeighborsClassifier):
         if sklearn_check_version('1.2'):
             _parameter_constraints: dict = {
                 **sklearn_KNeighborsClassifier._parameter_constraints}
@@ -92,15 +92,15 @@
                 algorithm=algorithm,
                 leaf_size=leaf_size, metric=metric, p=p,
                 metric_params=metric_params,
                 n_jobs=n_jobs, **kwargs)
             self.weights = _check_weights(weights)
 
 
-class KNeighborsClassifier(KNeighborsClassifier_):
+class KNeighborsClassifier(KNeighborsClassifier_, KNeighborsDispatchingBase):
     if sklearn_check_version('1.2'):
         _parameter_constraints: dict = {
             **KNeighborsClassifier_._parameter_constraints}
 
     if sklearn_check_version('1.0'):
         def __init__(self, n_neighbors=5, *,
                      weights='uniform', algorithm='auto', leaf_size=30,
@@ -226,46 +226,46 @@
         elif isinstance(X, KDTree):
             self._fit_X = X.data
             self._tree = X
             self._fit_method = 'kd_tree'
             self.n_samples_fit_ = X.data.shape[0]
             self.n_features_in_ = X.data.shape[1]
 
-        dispatch(self, 'neighbors.KNeighborsClassifier.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
             'sklearn': sklearn_KNeighborsClassifier.fit,
         }, X, y)
         return self
 
     @wrap_output_data
     def predict(self, X):
         check_is_fitted(self)
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'neighbors.KNeighborsClassifier.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
             'sklearn': sklearn_KNeighborsClassifier.predict,
         }, X)
 
     @wrap_output_data
     def predict_proba(self, X):
         check_is_fitted(self)
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'neighbors.KNeighborsClassifier.predict_proba', {
+        return dispatch(self, 'predict_proba', {
             'onedal': self.__class__._onedal_predict_proba,
             'sklearn': sklearn_KNeighborsClassifier.predict_proba,
         }, X)
 
     @wrap_output_data
     def kneighbors(self, X=None, n_neighbors=None, return_distance=True):
         check_is_fitted(self)
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'neighbors.KNeighborsClassifier.kneighbors', {
+        return dispatch(self, 'kneighbors', {
             'onedal': self.__class__._onedal_kneighbors,
             'sklearn': sklearn_KNeighborsClassifier.kneighbors,
         }, X, n_neighbors, return_distance)
 
     @wrap_output_data
     def radius_neighbors(self, X=None, radius=None, return_distance=True,
                          sort_results=False):
@@ -282,120 +282,14 @@
                 self, X, radius, return_distance, sort_results)
         else:
             result = sklearn_NearestNeighbors.radius_neighbors(
                 self, X, radius, return_distance)
 
         return result
 
-    def _onedal_gpu_supported(self, method_name, *data):
-        X_incorrect_type = isinstance(data[0], (KDTree, BallTree, sklearn_NeighborsBase))
-
-        if X_incorrect_type:
-            return False
-
-        if self._fit_method in ['auto', 'ball_tree']:
-            condition = self.n_neighbors is not None and \
-                self.n_neighbors >= self.n_samples_fit_ // 2
-            if self.n_features_in_ > 15 or condition:
-                result_method = 'brute'
-            else:
-                if self.effective_metric_ in ['euclidean']:
-                    result_method = 'kd_tree'
-                else:
-                    result_method = 'brute'
-        else:
-            result_method = self._fit_method
-
-        if "p" in self.effective_metric_params_.keys() and \
-                self.effective_metric_params_["p"] < 1:
-            return False
-
-        is_sparse = sp.isspmatrix(data[0])
-        is_single_output = False
-        class_count = 1
-        if len(data) > 1 or hasattr(self, '_onedal_estimator'):
-            # To check multioutput, might be overhead
-            if len(data) > 1:
-                y = np.asarray(data[1])
-                class_count = len(np.unique(y))
-            if hasattr(self, '_onedal_estimator'):
-                y = self._onedal_estimator._y
-            is_single_output = y.ndim == 1 or y.ndim == 2 and y.shape[1] == 1
-        is_valid_for_brute = result_method in ['brute'] and \
-            self.effective_metric_ in ['manhattan',
-                                       'minkowski',
-                                       'euclidean',
-                                       'chebyshev',
-                                       'cosine']
-        is_valid_weights = self.weights in ['uniform', "distance"]
-        main_condition = is_valid_for_brute and not is_sparse and \
-            is_single_output and is_valid_weights
-
-        if method_name == 'neighbors.KNeighborsClassifier.fit':
-            return main_condition and class_count >= 2
-        if method_name in ['neighbors.KNeighborsClassifier.predict',
-                           'neighbors.KNeighborsClassifier.predict_proba',
-                           'neighbors.KNeighborsClassifier.kneighbors']:
-            return main_condition and hasattr(self, '_onedal_estimator')
-        raise RuntimeError(f'Unknown method {method_name} in {self.__class__.__name__}')
-
-    def _onedal_cpu_supported(self, method_name, *data):
-        X_incorrect_type = isinstance(data[0], (KDTree, BallTree, sklearn_NeighborsBase))
-
-        if X_incorrect_type:
-            return False
-
-        if self._fit_method in ['auto', 'ball_tree']:
-            condition = self.n_neighbors is not None and \
-                self.n_neighbors >= self.n_samples_fit_ // 2
-            if self.n_features_in_ > 15 or condition:
-                result_method = 'brute'
-            else:
-                if self.effective_metric_ in ['euclidean']:
-                    result_method = 'kd_tree'
-                else:
-                    result_method = 'brute'
-        else:
-            result_method = self._fit_method
-
-        if "p" in self.effective_metric_params_.keys() and \
-                self.effective_metric_params_["p"] < 1:
-            return False
-
-        is_sparse = sp.isspmatrix(data[0])
-        is_single_output = False
-        class_count = 1
-        if len(data) > 1 or hasattr(self, '_onedal_estimator'):
-            # To check multioutput, might be overhead
-            if len(data) > 1:
-                y = np.asarray(data[1])
-                class_count = len(np.unique(y))
-            if hasattr(self, '_onedal_estimator'):
-                y = self._onedal_estimator._y
-            is_single_output = y.ndim == 1 or y.ndim == 2 and y.shape[1] == 1
-        is_valid_for_kd_tree = \
-            result_method in ['kd_tree'] and self.effective_metric_ in ['euclidean']
-        is_valid_for_brute = result_method in ['brute'] and \
-            self.effective_metric_ in ['manhattan',
-                                       'minkowski',
-                                       'euclidean',
-                                       'chebyshev',
-                                       'cosine']
-        is_valid_weights = self.weights in ['uniform', "distance"]
-        main_condition = (is_valid_for_kd_tree or is_valid_for_brute) and \
-            not is_sparse and is_single_output and is_valid_weights
-
-        if method_name == 'neighbors.KNeighborsClassifier.fit':
-            return main_condition and class_count >= 2
-        if method_name in ['neighbors.KNeighborsClassifier.predict',
-                           'neighbors.KNeighborsClassifier.predict_proba',
-                           'neighbors.KNeighborsClassifier.kneighbors']:
-            return main_condition and hasattr(self, '_onedal_estimator')
-        raise RuntimeError(f'Unknown method {method_name} in {self.__class__.__name__}')
-
     def _onedal_fit(self, X, y, queue=None):
         onedal_params = {
             'n_neighbors': self.n_neighbors,
             'weights': self.weights,
             'algorithm': self.algorithm,
             'metric': self.effective_metric_,
             'p': self.p,
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/knn_unsupervised.py` & `sklearnex/neighbors/knn_unsupervised.py`

 * *Files 14% similar despite different names*

```diff
@@ -31,17 +31,17 @@
     sklearn_NearestNeighbors
 
 from sklearn.utils.validation import _deprecate_positional_args, check_is_fitted
 
 from onedal.datatypes import _check_array, _num_features, _num_samples
 from onedal.neighbors import NearestNeighbors as onedal_NearestNeighbors
 
+from .common import KNeighborsDispatchingBase
 from .._device_offload import dispatch, wrap_output_data
 import numpy as np
-from scipy import sparse as sp
 
 
 if sklearn_check_version("0.22") and \
    Version(sklearn_version) < Version("0.23"):
     class NearestNeighbors_(sklearn_NearestNeighbors):
         def __init__(self, n_neighbors=5, radius=1.0,
                      algorithm='auto', leaf_size=30, metric='minkowski',
@@ -66,15 +66,15 @@
                 n_neighbors=n_neighbors,
                 radius=radius,
                 algorithm=algorithm,
                 leaf_size=leaf_size, metric=metric, p=p,
                 metric_params=metric_params, n_jobs=n_jobs)
 
 
-class NearestNeighbors(NearestNeighbors_):
+class NearestNeighbors(NearestNeighbors_, KNeighborsDispatchingBase):
     if sklearn_check_version('1.2'):
         _parameter_constraints: dict = {
             **NearestNeighbors_._parameter_constraints}
 
     @_deprecate_positional_args
     def __init__(self, n_neighbors=5, radius=1.0,
                  algorithm='auto', leaf_size=30, metric='minkowski',
@@ -186,26 +186,26 @@
         elif isinstance(X, KDTree):
             self._fit_X = X.data
             self._tree = X
             self._fit_method = 'kd_tree'
             self.n_samples_fit_ = X.data.shape[0]
             self.n_features_in_ = X.data.shape[1]
 
-        dispatch(self, 'neighbors.NearestNeighbors.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
             'sklearn': sklearn_NearestNeighbors.fit,
         }, X, None)
         return self
 
     @wrap_output_data
     def kneighbors(self, X=None, n_neighbors=None, return_distance=True):
         check_is_fitted(self)
         if sklearn_check_version("1.0") and X is not None:
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'neighbors.NearestNeighbors.kneighbors', {
+        return dispatch(self, 'kneighbors', {
             'onedal': self.__class__._onedal_kneighbors,
             'sklearn': sklearn_NearestNeighbors.kneighbors,
         }, X, n_neighbors, return_distance)
 
     @wrap_output_data
     def radius_neighbors(self, X=None, radius=None, return_distance=True,
                          sort_results=False):
@@ -222,92 +222,14 @@
                 self, X, radius, return_distance, sort_results)
         else:
             result = sklearn_NearestNeighbors.radius_neighbors(
                 self, X, radius, return_distance)
 
         return result
 
-    def _onedal_gpu_supported(self, method_name, *data):
-        X_incorrect_type = isinstance(data[0], (KDTree, BallTree, sklearn_NeighborsBase))
-
-        if X_incorrect_type:
-            return False
-
-        if self._fit_method in ['auto', 'ball_tree']:
-            condition = self.n_neighbors is not None and \
-                self.n_neighbors >= self.n_samples_fit_ // 2
-            if self.n_features_in_ > 15 or condition:
-                result_method = 'brute'
-            else:
-                if self.effective_metric_ in ['euclidean']:
-                    result_method = 'kd_tree'
-                else:
-                    result_method = 'brute'
-        else:
-            result_method = self._fit_method
-
-        if "p" in self.effective_metric_params_.keys() and \
-                self.effective_metric_params_["p"] < 1:
-            return False
-
-        is_sparse = sp.isspmatrix(data[0])
-        is_valid_for_brute = result_method in ['brute'] and \
-            self.effective_metric_ in ['manhattan',
-                                       'minkowski',
-                                       'euclidean',
-                                       'chebyshev',
-                                       'cosine']
-        main_condition = is_valid_for_brute and not is_sparse
-
-        if method_name == 'neighbors.NearestNeighbors.fit':
-            return main_condition
-        if method_name in ['neighbors.NearestNeighbors.kneighbors']:
-            return main_condition and hasattr(self, '_onedal_estimator')
-        raise RuntimeError(f'Unknown method {method_name} in {self.__class__.__name__}')
-
-    def _onedal_cpu_supported(self, method_name, *data):
-        X_incorrect_type = isinstance(data[0], (KDTree, BallTree, sklearn_NeighborsBase))
-
-        if X_incorrect_type:
-            return False
-
-        if self._fit_method in ['auto', 'ball_tree']:
-            condition = self.n_neighbors is not None and \
-                self.n_neighbors >= self.n_samples_fit_ // 2
-            if self.n_features_in_ > 15 or condition:
-                result_method = 'brute'
-            else:
-                if self.effective_metric_ in ['euclidean']:
-                    result_method = 'kd_tree'
-                else:
-                    result_method = 'brute'
-        else:
-            result_method = self._fit_method
-
-        if "p" in self.effective_metric_params_.keys() and \
-                self.effective_metric_params_["p"] < 1:
-            return False
-
-        is_sparse = sp.isspmatrix(data[0])
-        is_valid_for_kd_tree = \
-            result_method in ['kd_tree'] and self.effective_metric_ in ['euclidean']
-        is_valid_for_brute = result_method in ['brute'] and \
-            self.effective_metric_ in ['manhattan',
-                                       'minkowski',
-                                       'euclidean',
-                                       'chebyshev',
-                                       'cosine']
-        main_condition = (is_valid_for_kd_tree or is_valid_for_brute) and not is_sparse
-
-        if method_name == 'neighbors.NearestNeighbors.fit':
-            return main_condition
-        if method_name in ['neighbors.NearestNeighbors.kneighbors']:
-            return main_condition and hasattr(self, '_onedal_estimator')
-        raise RuntimeError(f'Unknown method {method_name} in {self.__class__.__name__}')
-
     def _onedal_fit(self, X, y=None, queue=None):
         onedal_params = {
             'n_neighbors': self.n_neighbors,
             'algorithm': self.algorithm,
             'metric': self.effective_metric_,
             'p': self.p,
         }
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/lof.py` & `sklearnex/neighbors/lof.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,32 +16,25 @@
 #===============================================================================
 
 import numpy as np
 import warnings
 
 from sklearn.neighbors._lof import LocalOutlierFactor as \
     sklearn_LocalOutlierFactor
-
 from .knn_unsupervised import NearestNeighbors
 
 try:
     from sklearn.utils.metaestimators import available_if
-    from packaging.version import Version
 except ImportError:
-    from distutils.version import LooseVersion as Version
-
-from sklearn import __version__ as sklearn_version
-
-from daal4py.sklearn._utils import sklearn_check_version
+    pass
 
 from sklearn.utils.validation import check_is_fitted
 from sklearn.utils import check_array
 
-import logging
-from .._utils import get_patch_message
+from daal4py.sklearn._utils import sklearn_check_version
 from .._device_offload import dispatch, wrap_output_data
 from .._config import config_context
 
 if sklearn_check_version("1.0"):
     class LocalOutlierFactor(sklearn_LocalOutlierFactor):
         if sklearn_check_version('1.2'):
             _parameter_constraints: dict = {
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/neighbors/tests/test_neighbors.py` & `sklearnex/neighbors/tests/test_neighbors.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/__init__.py` & `sklearnex/preview/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/__init__.py` & `sklearnex/preview/decomposition/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/pca.py` & `sklearnex/preview/decomposition/pca.py`

 * *Files 2% similar despite different names*

```diff
@@ -162,15 +162,15 @@
             if sklearn_check_version('0.23'):
                 X = self._validate_data(X, copy=self.copy)
             else:
                 X = check_array(X, copy=self.copy)
 
         # Call different fits for either full or truncated SVD
         if shape_good_for_daal and self._fit_svd_solver == "full":
-            return dispatch(self, 'decomposition.PCA.fit', {
+            return dispatch(self, 'fit', {
                 'onedal': self.__class__._onedal_fit,
                 'sklearn': sklearn_PCA._fit_full,
             }, X)
         elif not shape_good_for_daal and self._fit_svd_solver == "full":
             return sklearn_PCA._fit_full(self, X, n_components)
         elif self._fit_svd_solver in ["arpack", "randomized"]:
             return sklearn_PCA._fit_truncated(
@@ -178,26 +178,26 @@
             )
         else:
             raise ValueError(
                 "Unrecognized svd_solver='{0}'".format(self._fit_svd_solver)
             )
 
     def _onedal_gpu_supported(self, method_name, *data):
-        if method_name == 'decomposition.PCA.fit':
+        if method_name == 'fit':
             return self._fit_svd_solver == 'full'
-        elif method_name == 'decomposition.PCA.transform':
+        elif method_name == 'transform':
             return hasattr(self, '_onedal_estimator')
         raise RuntimeError(
             f'Unknown method {method_name} in {self.__class__.__name__}'
         )
 
     def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'decomposition.PCA.fit':
+        if method_name == 'fit':
             return self._fit_svd_solver == 'full'
-        elif method_name == 'decomposition.PCA.transform':
+        elif method_name == 'transform':
             return hasattr(self, '_onedal_estimator')
         raise RuntimeError(
             f'Unknown method {method_name} in {self.__class__.__name__}'
         )
 
     def _onedal_fit(self, X, y=None, queue=None):
 
@@ -247,15 +247,15 @@
                     f"X has {X.shape[1]} features, "
                     f"but {self.__class__.__name__} is expecting "
                     f"{self.n_features_} features as input"
                 )
 
         # Mean center
         X_centered = X - self.mean_
-        return dispatch(self, 'decomposition.PCA.transform', {
+        return dispatch(self, 'transform', {
             'onedal': self.__class__._onedal_predict,
             'sklearn': sklearn_PCA.transform,
         }, X_centered)
 
     def transform(self, X):
         check_is_fitted(self)
         if hasattr(self, "_onedal_estimator"):
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/decomposition/tests/test_preview_pca.py` & `sklearnex/preview/linear_model/tests/test_preview_linear.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,28 +1,36 @@
 #!/usr/bin/env python
-#===============================================================================
-# Copyright 2023 Intel Corporation
+# ===============================================================================
+# Copyright 2021 Intel Corporation
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-#===============================================================================
+# ===============================================================================
 
 import numpy as np
 from numpy.testing import assert_allclose
+from sklearn.datasets import make_regression
+from daal4py.sklearn._utils import daal_check_version
 
 
-def test_sklearnex_import():
-    from sklearnex.preview.decomposition import PCA
-    X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])
-    pca = PCA(n_components=2, svd_solver='full').fit(X)
-    assert 'sklearnex' in pca.__module__
-    assert hasattr(pca, '_onedal_estimator')
-    assert_allclose(pca.singular_values_, [6.30061232, 0.54980396])
+def test_sklearnex_import_linear():
+    from sklearnex.preview.linear_model import LinearRegression
+    X = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])
+    y = np.dot(X, np.array([1, 2])) + 3
+    linreg = LinearRegression().fit(X, y)
+    if daal_check_version((2023, 'P', 100)):
+        assert 'sklearnex' in linreg.__module__
+        assert hasattr(linreg, '_onedal_estimator')
+    else:
+        assert 'daal4py' in linreg.__module__
+    assert linreg.n_features_in_ == 2
+    assert_allclose(linreg.intercept_, 3.)
+    assert_allclose(linreg.coef_, [1., 2.])
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/__init__.py` & `sklearnex/spmd/ensemble/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,19 @@
-#!/usr/bin/env python
-# ===============================================================================
-# Copyright 2023 Intel Corporation
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# ===============================================================================
-
-from .forest import RandomForestClassifier, RandomForestRegressor
-
-__all__ = ['RandomForestClassifier', 'RandomForestRegressor']
+#===============================================================================
+# Copyright 2023 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#===============================================================================
+
+from .forest import RandomForestClassifier, RandomForestRegressor
+
+__all__ = ['RandomForestClassifier', 'RandomForestRegressor']
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/forest.py` & `sklearnex/preview/ensemble/forest.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,40 +13,40 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 # ===============================================================================
 
 from daal4py.sklearn._utils import (
     daal_check_version, sklearn_check_version,
-    make2d, get_dtype
+    make2d, check_tree_nodes
 )
 
 import numpy as np
 
 import numbers
 
 import warnings
 
 from abc import ABC
 
 from sklearn.exceptions import DataConversionWarning
 
-from ..._config import get_config, config_context
+from ..._config import get_config
 from ..._device_offload import dispatch, wrap_output_data
 
 from sklearn.ensemble import RandomForestClassifier as sklearn_RandomForestClassifier
 from sklearn.ensemble import RandomForestRegressor as sklearn_RandomForestRegressor
 
 from sklearn.utils.validation import (
     check_is_fitted,
     check_consistent_length,
     check_array,
     check_X_y)
 
-from onedal.datatypes import _check_array, _num_features, _num_samples
+from onedal.datatypes import _num_features, _num_samples
 
 from sklearn.utils import check_random_state, deprecated
 
 from sklearn.base import clone
 
 from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
 from sklearn.tree._tree import Tree
@@ -323,15 +323,15 @@
             classification, splits are also ignored if they would result in any
             single class carrying a negative weight in either child node.
 
         Returns
         -------
         self : object
         """
-        dispatch(self, 'ensemble.RandomForestClassifier.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
             'sklearn': sklearn_RandomForestClassifier.fit,
         }, X, y, sample_weight)
         return self
 
     def _onedal_ready(self, X, y, sample_weight):
         if sp.issparse(y):
@@ -408,15 +408,15 @@
             converted into a sparse ``csr_matrix``.
 
         Returns
         -------
         y : ndarray of shape (n_samples,) or (n_samples, n_outputs)
             The predicted classes.
         """
-        return dispatch(self, 'ensemble.RandomForestClassifier.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
             'sklearn': sklearn_RandomForestClassifier.predict,
         }, X)
 
     @wrap_output_data
     def predict_proba(self, X):
         """
@@ -452,15 +452,15 @@
             except TypeError:
                 num_features = _num_samples(X)
             if num_features != self.n_features_in_:
                 raise ValueError(
                     (f'X has {num_features} features, '
                      f'but RandomForestClassifier is expecting '
                      f'{self.n_features_in_} features as input'))
-        return dispatch(self, 'ensemble.RandomForestClassifier.predict_proba', {
+        return dispatch(self, 'predict_proba', {
             'onedal': self.__class__._onedal_predict_proba,
             'sklearn': sklearn_RandomForestClassifier.predict_proba,
         }, X)
 
     if sklearn_check_version('1.0'):
         @deprecated(
             "Attribute `n_features_` was deprecated in version 1.0 and will be "
@@ -513,30 +513,30 @@
             est_i.classes_ = classes_
             est_i.n_classes_ = n_classes_
             tree_i_state_class = get_tree_state_cls(
                 self._onedal_model, i, n_classes_)
             tree_i_state_dict = {
                 'max_depth': tree_i_state_class.max_depth,
                 'node_count': tree_i_state_class.node_count,
-                'nodes': tree_i_state_class.node_ar,
+                'nodes': check_tree_nodes(tree_i_state_class.node_ar),
                 'values': tree_i_state_class.value_ar}
             est_i.tree_ = Tree(
                 self.n_features_in_,
                 np.array(
                     [n_classes_],
                     dtype=np.intp),
                 self.n_outputs_)
             est_i.tree_.__setstate__(tree_i_state_dict)
             estimators_.append(est_i)
 
         self._cached_estimators_ = estimators_
         return estimators_
 
     def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'ensemble.RandomForestClassifier.fit':
+        if method_name == 'fit':
             ready, X, y, sample_weight = self._onedal_ready(*data)
             if self.splitter_mode == 'random':
                 warnings.warn("'random' splitter mode supports GPU devices only "
                               "and requires oneDAL version >= 2023.1.1. "
                               "Using 'best' mode instead.", RuntimeWarning)
                 self.splitter_mode = 'best'
             if not ready:
@@ -555,16 +555,15 @@
                 return False
             elif not self.n_outputs_ == 1:
                 return False
             elif hasattr(self, 'estimators_'):
                 return False
             else:
                 return True
-        if method_name in ['ensemble.RandomForestClassifier.predict',
-                           'ensemble.RandomForestClassifier.predict_proba']:
+        if method_name in ['predict', 'predict_proba']:
             X = data[0]
             if not hasattr(self, '_onedal_model'):
                 return False
             elif sp.issparse(X):
                 return False
             elif not (hasattr(self, 'n_outputs_') and self.n_outputs_ == 1):
                 return False
@@ -574,15 +573,15 @@
                 return False
             else:
                 return True
         raise RuntimeError(
             f'Unknown method {method_name} in {self.__class__.__name__}')
 
     def _onedal_gpu_supported(self, method_name, *data):
-        if method_name == 'ensemble.RandomForestClassifier.fit':
+        if method_name == 'fit':
             ready, X, y, sample_weight = self._onedal_ready(*data)
             if self.splitter_mode == 'random' and \
                     not daal_check_version((2023, 'P', 101)):
                 warnings.warn("'random' splitter mode requires OneDAL >= 2023.1.1. "
                               "Using 'best' mode instead.", RuntimeWarning)
                 self.splitter_mode = 'best'
             if not ready:
@@ -603,16 +602,15 @@
                 return False
             elif not self.n_outputs_ == 1:
                 return False
             elif hasattr(self, 'estimators_'):
                 return False
             else:
                 return True
-        if method_name in ['ensemble.RandomForestClassifier.predict',
-                           'ensemble.RandomForestClassifier.predict_proba']:
+        if method_name in ['predict', 'predict_proba']:
             X = data[0]
             if not hasattr(self, '_onedal_model'):
                 return False
             elif sp.issparse(X):
                 return False
             elif not (hasattr(self, 'n_outputs_') and self.n_outputs_ == 1):
                 return False
@@ -890,15 +888,15 @@
             est_i.n_classes_ = 1
             est_i.n_outputs_ = self.n_outputs_
             tree_i_state_class = get_tree_state_reg(
                 self._onedal_model, i)
             tree_i_state_dict = {
                 'max_depth': tree_i_state_class.max_depth,
                 'node_count': tree_i_state_class.node_count,
-                'nodes': tree_i_state_class.node_ar,
+                'nodes': check_tree_nodes(tree_i_state_class.node_ar),
                 'values': tree_i_state_class.value_ar}
 
             est_i.tree_ = Tree(
                 self.n_features_in_, np.array(
                     [1], dtype=np.intp), self.n_outputs_)
             est_i.tree_.__setstate__(tree_i_state_dict)
             estimators_.append(est_i)
@@ -918,15 +916,15 @@
             # [:, np.newaxis] that does not.
             y = np.reshape(y, (-1, 1))
         self.n_outputs_ = y.shape[1]
         ready = self.n_outputs_ == 1
         return ready, X, y, sample_weight
 
     def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'ensemble.RandomForestRegressor.fit':
+        if method_name == 'fit':
             ready, X, y, sample_weight = self._onedal_ready(*data)
             if self.splitter_mode == 'random':
                 warnings.warn("'random' splitter mode supports GPU devices only "
                               "and requires oneDAL version >= 2023.1.1. "
                               "Using 'best' mode instead.", RuntimeWarning)
                 self.splitter_mode = 'best'
             if not ready:
@@ -950,16 +948,15 @@
                 return False
             elif not self.n_outputs_ == 1:
                 return False
             elif hasattr(self, 'estimators_'):
                 return False
             else:
                 return True
-        if method_name in ['ensemble.RandomForestRegressor.predict',
-                           'ensemble.RandomForestRegressor.predict_proba']:
+        if method_name == 'predict':
             if not hasattr(self, '_onedal_model'):
                 return False
             elif sp.issparse(data[0]):
                 return False
             elif not (hasattr(self, 'n_outputs_') and self.n_outputs_ == 1):
                 return False
             elif not daal_check_version((2021, 'P', 400)):
@@ -968,15 +965,15 @@
                 return False
             else:
                 return True
         raise RuntimeError(
             f'Unknown method {method_name} in {self.__class__.__name__}')
 
     def _onedal_gpu_supported(self, method_name, *data):
-        if method_name == 'ensemble.RandomForestRegressor.fit':
+        if method_name == 'fit':
             ready, X, y, sample_weight = self._onedal_ready(*data)
             if self.splitter_mode == 'random' and \
                     not daal_check_version((2023, 'P', 101)):
                 warnings.warn("'random' splitter mode requires OneDAL >= 2023.1.1. "
                               "Using 'best' mode instead.", RuntimeWarning)
                 self.splitter_mode = 'best'
             if not ready:
@@ -998,16 +995,15 @@
                 return False
             elif self.oob_score:
                 return False
             elif hasattr(self, 'estimators_'):
                 return False
             else:
                 return True
-        if method_name in ['ensemble.RandomForestRegressor.predict',
-                           'ensemble.RandomForestRegressor.predict_proba']:
+        if method_name == 'predict':
             X = data[0]
             if not hasattr(self, '_onedal_model'):
                 return False
             elif sp.issparse(X):
                 return False
             elif not (hasattr(self, 'n_outputs_') and self.n_outputs_ == 1):
                 return False
@@ -1113,15 +1109,15 @@
         """
         if not self.bootstrap and self.max_samples is not None:
             raise ValueError(
                 "`max_sample` cannot be set if `bootstrap=False`. "
                 "Either switch to `bootstrap=True` or set "
                 "`max_sample=None`."
             )
-        dispatch(self, 'ensemble.RandomForestRegressor.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
             'sklearn': sklearn_RandomForestRegressor.fit,
         }, X, y, sample_weight)
         return self
 
     @wrap_output_data
     def predict(self, X):
@@ -1141,15 +1137,15 @@
             converted into a sparse ``csr_matrix``.
 
         Returns
         -------
         y : ndarray of shape (n_samples,) or (n_samples, n_outputs)
             The predicted classes.
         """
-        return dispatch(self, 'ensemble.RandomForestRegressor.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
             'sklearn': sklearn_RandomForestRegressor.predict,
         }, X)
 
     if sklearn_check_version('1.0'):
         @deprecated(
             "Attribute `n_features_` was deprecated in version 1.0 and will be "
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/ensemble/tests/test_random_preview_forest.py` & `sklearnex/preview/ensemble/tests/test_preview_ensemble.py`

 * *Files 23% similar despite different names*

```diff
@@ -11,17 +11,17 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-import numpy as np
 from numpy.testing import assert_allclose
 from sklearn.datasets import make_classification, make_regression
+from daal4py.sklearn._utils import daal_check_version
 
 
 def test_sklearnex_import_rf_classifier():
     from sklearnex.preview.ensemble import RandomForestClassifier
     X, y = make_classification(n_samples=1000, n_features=4,
                                n_informative=2, n_redundant=0,
                                random_state=0, shuffle=False)
@@ -34,7 +34,34 @@
     from sklearnex.preview.ensemble import RandomForestRegressor
     X, y = make_regression(n_features=4, n_informative=2,
                            random_state=0, shuffle=False)
     rf = RandomForestRegressor(max_depth=2, random_state=0).fit(X, y)
     assert 'sklearnex.preview' in rf.__module__
     pred = rf.predict([[0, 0, 0, 0]])
     assert_allclose([-6.839], pred, atol=1e-2)
+
+
+def test_sklearnex_import_et_classifier():
+    from sklearnex.preview.ensemble import ExtraTreesClassifier
+    X, y = make_classification(n_samples=1000, n_features=4,
+                               n_informative=2, n_redundant=0,
+                               random_state=0, shuffle=False)
+    # For the 2023.2 release, random_state is not supported
+    # defaults to seed=777, although it is set to 0
+    rf = ExtraTreesClassifier(max_depth=2, random_state=0).fit(X, y)
+    assert 'sklearnex' in rf.__module__
+    assert_allclose([1], rf.predict([[0, 0, 0, 0]]))
+
+
+def test_sklearnex_import_et_regression():
+    from sklearnex.preview.ensemble import ExtraTreesRegressor
+    X, y = make_regression(n_features=4, n_informative=2,
+                           random_state=0, shuffle=False)
+    # For the 2023.2 release, random_state is not supported
+    # defaults to seed=777, although it is set to 0
+    rf = ExtraTreesRegressor(max_depth=2, random_state=0).fit(X, y)
+    assert 'sklearnex' in rf.__module__
+    pred = rf.predict([[0, 0, 0, 0]])
+    if daal_check_version((2023, 'P', 200)):
+        assert_allclose([27.138], pred, atol=1e-2)
+    else:
+        assert_allclose([-2.826], pred, atol=1e-2)
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/__init__.py` & `sklearnex/preview/linear_model/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/_common.py` & `sklearnex/preview/linear_model/_common.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/preview/linear_model/linear.py` & `sklearnex/preview/linear_model/linear.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,25 +10,26 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 # ===============================================================================
 
-from daal4py.sklearn._utils import daal_check_version, sklearn_check_version
+from daal4py.sklearn._utils import daal_check_version
 import logging
 
 if daal_check_version((2023, 'P', 100)):
     import numpy as np
 
     from ._common import BaseLinearRegression
     from ..._device_offload import dispatch, wrap_output_data
 
-    from ...utils.validation import assert_all_finite
-    from daal4py.sklearn._utils import (get_dtype, make2d)
+    from ...utils.validation import _assert_all_finite
+    from daal4py.sklearn._utils import (
+        get_dtype, make2d, sklearn_check_version, PatchingConditionsChain)
     from sklearn.linear_model import LinearRegression as sklearn_LinearRegression
 
     if sklearn_check_version('1.0') and not sklearn_check_version('1.2'):
         from sklearn.linear_model._base import _deprecate_normalize
 
     from sklearn.utils.validation import _deprecate_positional_args, check_X_y
     from sklearn.exceptions import NotFittedError
@@ -109,15 +110,15 @@
                 Fitted Estimator.
             """
             if sklearn_check_version('1.0'):
                 self._check_feature_names(X, reset=True)
             if sklearn_check_version("1.2"):
                 self._validate_params()
 
-            dispatch(self, 'linear_model.LinearRegression.fit', {
+            dispatch(self, 'fit', {
                 'onedal': self.__class__._onedal_fit,
                 'sklearn': sklearn_LinearRegression.fit,
             }, X, y, sample_weight)
             return self
 
         @wrap_output_data
         def predict(self, X):
@@ -130,94 +131,101 @@
             Returns
             -------
             C : array, shape (n_samples, n_targets)
                 Returns predicted values.
             """
             if sklearn_check_version("1.0"):
                 self._check_feature_names(X, reset=False)
-            return dispatch(self, 'linear_model.LinearRegression.predict', {
+            return dispatch(self, 'predict', {
                 'onedal': self.__class__._onedal_predict,
                 'sklearn': sklearn_LinearRegression.predict,
             }, X)
 
         def _test_type_and_finiteness(self, X_in):
             X = X_in if isinstance(X_in, np.ndarray) else np.asarray(X_in)
 
             dtype = X.dtype
             if 'complex' in str(type(dtype)):
                 return False
 
             try:
-                assert_all_finite(X)
+                _assert_all_finite(X)
             except BaseException:
                 return False
             return True
 
         def _onedal_fit_supported(self, method_name, *data):
-            assert method_name == 'linear_model.LinearRegression.fit'
-
+            assert method_name == 'fit'
             assert len(data) == 3
             X, y, sample_weight = data
 
-            if sample_weight is not None:
-                return False
-
-            if issparse(X) or issparse(y):
-                return False
-
-            if hasattr(self, 'normalize') and self.normalize \
-                    and self.normalize != 'deprecated':
-                return False
-
-            if hasattr(self, 'positive') and self.positive:
-                return False
+            class_name = self.__class__.__name__
+            patching_status = PatchingConditionsChain(
+                f'sklearn.linear_model.{class_name}.fit')
+
+            normalize_is_set = hasattr(self, 'normalize') and self.normalize \
+                and self.normalize != 'deprecated'
+            positive_is_set = hasattr(self, 'positive') and self.positive
 
             n_samples, n_features = _get_2d_shape(X, fallback_1d=True)
-
             # Check if equations are well defined
             is_good_for_onedal = n_samples > \
                 (n_features + int(self.fit_intercept))
-            if not is_good_for_onedal:
-                return False
 
-            if not self._test_type_and_finiteness(X):
-                return False
+            dal_ready = patching_status.and_conditions([
+                (sample_weight is None, 'Sample weight is not supported.'),
+                (not issparse(X) and not issparse(y), 'Sparse input is not supported.'),
+                (not normalize_is_set, 'Normalization is not supported.'),
+                (not positive_is_set, 'Forced positive coefficients are not supported.'),
+                (is_good_for_onedal,
+                 'The shape of X (fitting) does not satisfy oneDAL requirements:.'
+                 'Number of features + 1 >= number of samples.')
+            ])
+            if not dal_ready:
+                return patching_status.get_status(logs=True)
 
-            if not self._test_type_and_finiteness(y):
-                return False
+            if not patching_status.and_condition(
+                self._test_type_and_finiteness(X), 'Input X is not supported.'
+            ):
+                return patching_status.get_status(logs=True)
 
-            return True
+            patching_status.and_condition(
+                self._test_type_and_finiteness(y), 'Input y is not supported.')
 
-        def _onedal_predict_supported(self, method_name, *data):
-            assert method_name == 'linear_model.LinearRegression.predict'
+            return patching_status.get_status(logs=True)
 
+        def _onedal_predict_supported(self, method_name, *data):
+            assert method_name == 'predict'
             assert len(data) == 1
 
-            n_samples = _num_samples(*data)
-            if not (n_samples > 0):
-                return False
-
-            if issparse(*data) or issparse(self.coef_):
-                return False
+            class_name = self.__class__.__name__
+            patching_status = PatchingConditionsChain(
+                f'sklearn.linear_model.{class_name}.predict')
 
-            if self.fit_intercept and issparse(self.intercept_):
-                return False
-
-            if not hasattr(self, '_onedal_estimator'):
-                return False
+            n_samples = _num_samples(*data)
+            model_is_sparse = issparse(self.coef_) or \
+                (self.fit_intercept and issparse(self.intercept_))
+            dal_ready = patching_status.and_conditions([
+                (n_samples > 0, 'Number of samples is less than 1.'),
+                (not issparse(*data), 'Sparse input is not supported.'),
+                (not model_is_sparse, 'Sparse coefficients are not supported.'),
+                (hasattr(self, '_onedal_estimator'), 'oneDAL model was not trained.')
+            ])
+            if not dal_ready:
+                return patching_status.get_status(logs=True)
 
-            if not self._test_type_and_finiteness(*data):
-                return False
+            patching_status.and_condition(
+                self._test_type_and_finiteness(*data), 'Input X is not supported.')
 
-            return True
+            return patching_status.get_status(logs=True)
 
         def _onedal_supported(self, method_name, *data):
-            if method_name == 'linear_model.LinearRegression.fit':
+            if method_name == 'fit':
                 return self._onedal_fit_supported(method_name, *data)
-            if method_name == 'linear_model.LinearRegression.predict':
+            if method_name == 'predict':
                 return self._onedal_predict_supported(method_name, *data)
             raise RuntimeError(
                 f'Unknown method {method_name} in {self.__class__.__name__}')
 
         def _onedal_gpu_supported(self, method_name, *data):
             return self._onedal_supported(method_name, *data)
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/__init__.py` & `sklearnex/spmd/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/basic_statistics/__init__.py` & `sklearnex/spmd/basic_statistics/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/basic_statistics/basic_statistics.py` & `sklearnex/spmd/basic_statistics/basic_statistics.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/decomposition/__init__.py` & `sklearnex/spmd/decomposition/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/decomposition/pca.py` & `sklearnex/spmd/decomposition/pca.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/ensemble/__init__.py` & `sklearnex/spmd/neighbors/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -10,10 +10,10 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from .forest import RandomForestClassifier, RandomForestRegressor
+from .neighbors import KNeighborsClassifier, KNeighborsRegressor, NearestNeighbors
 
-__all__ = ['RandomForestClassifier', 'RandomForestRegressor']
+__all__ = ['KNeighborsClassifier', 'KNeighborsRegressor', 'NearestNeighbors']
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/ensemble/forest.py` & `sklearnex/spmd/ensemble/forest.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/linear_model/__init__.py` & `sklearnex/spmd/linear_model/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/linear_model/linear_model.py` & `sklearnex/spmd/linear_model/linear_model.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/spmd/neighbors/neighbors.py` & `sklearnex/spmd/neighbors/neighbors.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/__init__.py` & `sklearnex/svm/__init__.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/_common.py` & `sklearnex/svm/_common.py`

 * *Files 23% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
 from abc import ABC
 import numpy as np
-from daal4py.sklearn._utils import sklearn_check_version
+from daal4py.sklearn._utils import sklearn_check_version, PatchingConditionsChain
 
 from sklearn.model_selection import StratifiedKFold
 from sklearn.preprocessing import LabelEncoder
 from sklearn.calibration import CalibratedClassifierCV
 
 from onedal.datatypes.validation import _column_or_1d
 
@@ -45,15 +45,44 @@
     self._intercept_ = value
     if hasattr(self, '_onedal_estimator'):
         self._onedal_estimator.intercept_ = value
         if not self._is_in_fit:
             del self._onedal_estimator._onedal_model
 
 
-class BaseSVC(ABC):
+class BaseSVM(ABC):
+    def _onedal_gpu_supported(self, method_name, *data):
+        patching_status = PatchingConditionsChain(f'sklearn.{method_name}')
+        patching_status.and_conditions([
+            (False, 'GPU offloading is not supported.')
+        ])
+        return patching_status.get_status(logs=True)
+
+    def _onedal_cpu_supported(self, method_name, *data):
+        class_name = self.__class__.__name__
+        patching_status = PatchingConditionsChain(
+            f'sklearn.svm.{class_name}.{method_name}')
+        if method_name == 'fit':
+            patching_status.and_conditions([
+                (self.kernel in ['linear', 'rbf', 'poly', 'sigmoid'],
+                 f'Kernel is "{self.kernel}" while '
+                 '"linear", "rbf", "poly" and "sigmoid" are only supported.')
+            ])
+            return patching_status.get_status(logs=True)
+        inference_methods = ['predict'] if class_name.endswith('R') \
+            else ['predict', 'predict_proba', 'decision_function']
+        if method_name in inference_methods:
+            patching_status.and_conditions([
+                (hasattr(self, '_onedal_estimator'), 'oneDAL model was not trained.')
+            ])
+            return patching_status.get_status(logs=True)
+        raise RuntimeError(f'Unknown method {method_name} in {class_name}')
+
+
+class BaseSVC(BaseSVM):
     def _compute_balanced_class_weight(self, y):
         y_ = _column_or_1d(y)
         classes, _ = np.unique(y_, return_inverse=True)
 
         le = LabelEncoder()
         y_ind = le.fit_transform(y_)
         if not all(np.in1d(classes, le.classes_)):
@@ -127,15 +156,15 @@
         self._is_in_fit = False
 
         if sklearn_check_version("1.1"):
             length = int(len(self.classes_) * (len(self.classes_) - 1) / 2)
             self.n_iter_ = np.full((length, ), self._onedal_estimator.n_iter_)
 
 
-class BaseSVR(ABC):
+class BaseSVR(BaseSVM):
     def _save_attributes(self):
         self.support_vectors_ = self._onedal_estimator.support_vectors_
         self.n_features_in_ = self._onedal_estimator.n_features_in_
         self.fit_status_ = 0
         self.dual_coef_ = self._onedal_estimator.dual_coef_
         self.shape_fit_ = self._onedal_estimator.shape_fit_
         self.support_ = self._onedal_estimator.support_
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/nusvc.py` & `sklearnex/svm/svc.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,39 +10,42 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from daal4py.sklearn._utils import sklearn_check_version
+import numpy as np
+from scipy import sparse as sp
+
+from daal4py.sklearn._utils import sklearn_check_version, PatchingConditionsChain
 from ._common import BaseSVC
 from .._device_offload import dispatch, wrap_output_data
 
-from sklearn.svm import NuSVC as sklearn_NuSVC
+from sklearn.svm import SVC as sklearn_SVC
 from sklearn.utils.validation import _deprecate_positional_args
 from sklearn.exceptions import NotFittedError
 
-from onedal.svm import NuSVC as onedal_NuSVC
+from onedal.svm import SVC as onedal_SVC
 
 
-class NuSVC(sklearn_NuSVC, BaseSVC):
-    __doc__ = sklearn_NuSVC.__doc__
+class SVC(sklearn_SVC, BaseSVC):
+    __doc__ = sklearn_SVC.__doc__
 
     if sklearn_check_version('1.2'):
-        _parameter_constraints: dict = {**sklearn_NuSVC._parameter_constraints}
+        _parameter_constraints: dict = {**sklearn_SVC._parameter_constraints}
 
     @_deprecate_positional_args
-    def __init__(self, *, nu=0.5, kernel='rbf', degree=3, gamma='scale',
+    def __init__(self, *, C=1.0, kernel='rbf', degree=3, gamma='scale',
                  coef0=0.0, shrinking=True, probability=False,
                  tol=1e-3, cache_size=200, class_weight=None,
                  verbose=False, max_iter=-1, decision_function_shape='ovr',
                  break_ties=False, random_state=None):
         super().__init__(
-            nu=nu, kernel=kernel, degree=degree, gamma=gamma, coef0=coef0,
+            C=C, kernel=kernel, degree=degree, gamma=gamma, coef0=coef0,
             shrinking=shrinking, probability=probability, tol=tol, cache_size=cache_size,
             class_weight=class_weight, verbose=verbose, max_iter=max_iter,
             decision_function_shape=decision_function_shape, break_ties=break_ties,
             random_state=random_state)
 
     def fit(self, X, y, sample_weight=None):
         """
@@ -78,19 +81,18 @@
         If X is a dense array, then the other methods will not support sparse
         matrices as input.
         """
         if sklearn_check_version("1.2"):
             self._validate_params()
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=True)
-        dispatch(self, 'svm.NuSVC.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
-            'sklearn': sklearn_NuSVC.fit,
+            'sklearn': sklearn_SVC.fit,
         }, X, y, sample_weight)
-
         return self
 
     @wrap_output_data
     def predict(self, X):
         """
         Perform regression on samples in X.
 
@@ -105,17 +107,17 @@
         Returns
         -------
         y_pred : ndarray of shape (n_samples,)
             The predicted values.
         """
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'svm.NuSVC.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
-            'sklearn': sklearn_NuSVC.predict,
+            'sklearn': sklearn_SVC.predict,
         }, X)
 
     @property
     def predict_proba(self):
         """
         Compute probabilities of possible outcomes for samples in X.
 
@@ -143,62 +145,75 @@
         datasets.
         """
         self._check_proba()
         return self._predict_proba
 
     @wrap_output_data
     def _predict_proba(self, X):
-        if sklearn_check_version("1.0"):
-            self._check_feature_names(X, reset=False)
-        sklearn_pred_proba = (sklearn_NuSVC.predict_proba
+        sklearn_pred_proba = (sklearn_SVC.predict_proba
                               if sklearn_check_version("1.0")
-                              else sklearn_NuSVC._predict_proba)
+                              else sklearn_SVC._predict_proba)
 
-        return dispatch(self, 'svm.NuSVC.predict_proba', {
+        return dispatch(self, 'predict_proba', {
             'onedal': self.__class__._onedal_predict_proba,
             'sklearn': sklearn_pred_proba,
         }, X)
 
     @wrap_output_data
     def decision_function(self, X):
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'svm.NuSVC.decision_function', {
+        return dispatch(self, 'decision_function', {
             'onedal': self.__class__._onedal_decision_function,
-            'sklearn': sklearn_NuSVC.decision_function,
+            'sklearn': sklearn_SVC.decision_function,
         }, X)
 
     def _onedal_gpu_supported(self, method_name, *data):
-        return False
-
-    def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'svm.NuSVC.fit':
-            return self.kernel in ['linear', 'rbf', 'poly', 'sigmoid']
-        if method_name in ['svm.NuSVC.predict',
-                           'svm.NuSVC.predict_proba',
-                           'svm.NuSVC.decision_function']:
-            return hasattr(self, '_onedal_estimator')
+        class_name = self.__class__.__name__
+        patching_status = PatchingConditionsChain(
+            f'sklearn.svm.{class_name}.{method_name}')
+        if method_name == 'fit':
+            if len(data) > 1:
+                self._class_count = len(np.unique(data[1]))
+            self._is_sparse = sp.isspmatrix(data[0])
+            patching_status.and_conditions([
+                (self.kernel in ['linear', 'rbf'],
+                 f'Kernel is "{self.kernel}" while '
+                 '"linear" and "rbf" are only supported on GPU.'),
+                (self.class_weight is None, 'Class weight is not supported on GPU.'),
+                (self._class_count == 2, 'Multiclassification is not supported on GPU.'),
+                (not self._is_sparse, 'Sparse input is not supported on GPU.')
+            ])
+            return patching_status.get_status(logs=True)
+        if method_name in ['predict', 'predict_proba', 'decision_function']:
+            patching_status.and_conditions([
+                (hasattr(self, '_onedal_estimator') and self._onedal_gpu_supported(
+                    'fit', *data),
+                 'oneDAL model was not trained on GPU.')
+            ])
+            return patching_status.get_status(logs=True)
+        raise RuntimeError(f'Unknown method {method_name} in {class_name}')
 
     def _onedal_fit(self, X, y, sample_weight=None, queue=None):
         onedal_params = {
-            'nu': self.nu,
+            'C': self.C,
             'kernel': self.kernel,
             'degree': self.degree,
             'gamma': self.gamma,
             'coef0': self.coef0,
             'tol': self.tol,
             'shrinking': self.shrinking,
             'cache_size': self.cache_size,
             'max_iter': self.max_iter,
             'class_weight': self.class_weight,
             'break_ties': self.break_ties,
             'decision_function_shape': self.decision_function_shape,
         }
 
-        self._onedal_estimator = onedal_NuSVC(**onedal_params)
+        self._onedal_estimator = onedal_SVC(**onedal_params)
         self._onedal_estimator.fit(X, y, sample_weight, queue=queue)
 
         if self.probability:
             self._fit_proba(X, y, sample_weight, queue=queue)
         self._save_attributes()
 
     def _onedal_predict(self, X, queue=None):
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/nusvr.py` & `sklearnex/svm/nusvr.py`

 * *Files 14% similar despite different names*

```diff
@@ -72,15 +72,15 @@
         If X is a dense array, then the other methods will not support sparse
         matrices as input.
         """
         if sklearn_check_version("1.2"):
             self._validate_params()
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=True)
-        dispatch(self, 'svm.NuSVR.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
             'sklearn': sklearn_NuSVR.fit,
         }, X, y, sample_weight)
         return self
 
     @wrap_output_data
     def predict(self, X):
@@ -98,28 +98,19 @@
         Returns
         -------
         y_pred : ndarray of shape (n_samples,)
             The predicted values.
         """
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'svm.NuSVR.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
             'sklearn': sklearn_NuSVR.predict,
         }, X)
 
-    def _onedal_gpu_supported(self, method_name, *data):
-        return False
-
-    def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'svm.NuSVR.fit':
-            return self.kernel in ['linear', 'rbf', 'poly', 'sigmoid']
-        if method_name == 'svm.NuSVR.predict':
-            return hasattr(self, '_onedal_estimator')
-
     def _onedal_fit(self, X, y, sample_weight=None, queue=None):
         onedal_params = {
             'C': self.C,
             'nu': self.nu,
             'kernel': self.kernel,
             'degree': self.degree,
             'gamma': self.gamma,
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/svc.py` & `sklearnex/svm/nusvc.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,35 +14,35 @@
 # limitations under the License.
 #===============================================================================
 
 from daal4py.sklearn._utils import sklearn_check_version
 from ._common import BaseSVC
 from .._device_offload import dispatch, wrap_output_data
 
-from sklearn.svm import SVC as sklearn_SVC
+from sklearn.svm import NuSVC as sklearn_NuSVC
 from sklearn.utils.validation import _deprecate_positional_args
 from sklearn.exceptions import NotFittedError
 
-from onedal.svm import SVC as onedal_SVC
+from onedal.svm import NuSVC as onedal_NuSVC
 
 
-class SVC(sklearn_SVC, BaseSVC):
-    __doc__ = sklearn_SVC.__doc__
+class NuSVC(sklearn_NuSVC, BaseSVC):
+    __doc__ = sklearn_NuSVC.__doc__
 
     if sklearn_check_version('1.2'):
-        _parameter_constraints: dict = {**sklearn_SVC._parameter_constraints}
+        _parameter_constraints: dict = {**sklearn_NuSVC._parameter_constraints}
 
     @_deprecate_positional_args
-    def __init__(self, *, C=1.0, kernel='rbf', degree=3, gamma='scale',
+    def __init__(self, *, nu=0.5, kernel='rbf', degree=3, gamma='scale',
                  coef0=0.0, shrinking=True, probability=False,
                  tol=1e-3, cache_size=200, class_weight=None,
                  verbose=False, max_iter=-1, decision_function_shape='ovr',
                  break_ties=False, random_state=None):
         super().__init__(
-            C=C, kernel=kernel, degree=degree, gamma=gamma, coef0=coef0,
+            nu=nu, kernel=kernel, degree=degree, gamma=gamma, coef0=coef0,
             shrinking=shrinking, probability=probability, tol=tol, cache_size=cache_size,
             class_weight=class_weight, verbose=verbose, max_iter=max_iter,
             decision_function_shape=decision_function_shape, break_ties=break_ties,
             random_state=random_state)
 
     def fit(self, X, y, sample_weight=None):
         """
@@ -78,18 +78,19 @@
         If X is a dense array, then the other methods will not support sparse
         matrices as input.
         """
         if sklearn_check_version("1.2"):
             self._validate_params()
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=True)
-        dispatch(self, 'svm.SVC.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
-            'sklearn': sklearn_SVC.fit,
+            'sklearn': sklearn_NuSVC.fit,
         }, X, y, sample_weight)
+
         return self
 
     @wrap_output_data
     def predict(self, X):
         """
         Perform regression on samples in X.
 
@@ -104,17 +105,17 @@
         Returns
         -------
         y_pred : ndarray of shape (n_samples,)
             The predicted values.
         """
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'svm.SVC.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
-            'sklearn': sklearn_SVC.predict,
+            'sklearn': sklearn_NuSVC.predict,
         }, X)
 
     @property
     def predict_proba(self):
         """
         Compute probabilities of possible outcomes for samples in X.
 
@@ -142,77 +143,51 @@
         datasets.
         """
         self._check_proba()
         return self._predict_proba
 
     @wrap_output_data
     def _predict_proba(self, X):
-        sklearn_pred_proba = (sklearn_SVC.predict_proba
+        if sklearn_check_version("1.0"):
+            self._check_feature_names(X, reset=False)
+        sklearn_pred_proba = (sklearn_NuSVC.predict_proba
                               if sklearn_check_version("1.0")
-                              else sklearn_SVC._predict_proba)
+                              else sklearn_NuSVC._predict_proba)
 
-        return dispatch(self, 'svm.SVC.predict_proba', {
+        return dispatch(self, 'predict_proba', {
             'onedal': self.__class__._onedal_predict_proba,
             'sklearn': sklearn_pred_proba,
         }, X)
 
     @wrap_output_data
     def decision_function(self, X):
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'svm.SVC.decision_function', {
+        return dispatch(self, 'decision_function', {
             'onedal': self.__class__._onedal_decision_function,
-            'sklearn': sklearn_SVC.decision_function,
+            'sklearn': sklearn_NuSVC.decision_function,
         }, X)
 
-    def _onedal_gpu_supported(self, method_name, *data):
-        if method_name == 'svm.SVC.fit':
-            if len(data) > 1:
-                import numpy as np
-                from scipy import sparse as sp
-
-                self._class_count = len(np.unique(data[1]))
-                self._is_sparse = sp.isspmatrix(data[0])
-            return self.kernel in ['linear', 'rbf'] and \
-                self.class_weight is None and \
-                hasattr(self, '_class_count') and self._class_count == 2 and \
-                hasattr(self, '_is_sparse') and not self._is_sparse
-        if method_name in ['svm.SVC.predict',
-                           'svm.SVC.predict_proba',
-                           'svm.SVC.decision_function']:
-            return hasattr(self, '_onedal_estimator') and \
-                self._onedal_gpu_supported('svm.SVC.fit', *data)
-        raise RuntimeError(f'Unknown method {method_name} in {self.__class__.__name__}')
-
-    def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'svm.SVC.fit':
-            return self.kernel in ['linear', 'rbf', 'poly', 'sigmoid']
-        if method_name in ['svm.SVC.predict',
-                           'svm.SVC.predict_proba',
-                           'svm.SVC.decision_function']:
-            return hasattr(self, '_onedal_estimator')
-        raise RuntimeError(f'Unknown method {method_name} in {self.__class__.__name__}')
-
     def _onedal_fit(self, X, y, sample_weight=None, queue=None):
         onedal_params = {
-            'C': self.C,
+            'nu': self.nu,
             'kernel': self.kernel,
             'degree': self.degree,
             'gamma': self.gamma,
             'coef0': self.coef0,
             'tol': self.tol,
             'shrinking': self.shrinking,
             'cache_size': self.cache_size,
             'max_iter': self.max_iter,
             'class_weight': self.class_weight,
             'break_ties': self.break_ties,
             'decision_function_shape': self.decision_function_shape,
         }
 
-        self._onedal_estimator = onedal_SVC(**onedal_params)
+        self._onedal_estimator = onedal_NuSVC(**onedal_params)
         self._onedal_estimator.fit(X, y, sample_weight, queue=queue)
 
         if self.probability:
             self._fit_proba(X, y, sample_weight, queue=queue)
         self._save_attributes()
 
     def _onedal_predict(self, X, queue=None):
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/svr.py` & `sklearnex/svm/svr.py`

 * *Files 16% similar despite different names*

```diff
@@ -72,15 +72,15 @@
         If X is a dense array, then the other methods will not support sparse
         matrices as input.
         """
         if sklearn_check_version("1.2"):
             self._validate_params()
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=True)
-        dispatch(self, 'svm.SVR.fit', {
+        dispatch(self, 'fit', {
             'onedal': self.__class__._onedal_fit,
             'sklearn': sklearn_SVR.fit,
         }, X, y, sample_weight)
 
         return self
 
     @wrap_output_data
@@ -99,28 +99,19 @@
         Returns
         -------
         y_pred : ndarray of shape (n_samples,)
             The predicted values.
         """
         if sklearn_check_version("1.0"):
             self._check_feature_names(X, reset=False)
-        return dispatch(self, 'svm.SVR.predict', {
+        return dispatch(self, 'predict', {
             'onedal': self.__class__._onedal_predict,
             'sklearn': sklearn_SVR.predict,
         }, X)
 
-    def _onedal_gpu_supported(self, method_name, *data):
-        return False
-
-    def _onedal_cpu_supported(self, method_name, *data):
-        if method_name == 'svm.SVR.fit':
-            return self.kernel in ['linear', 'rbf', 'poly', 'sigmoid']
-        if method_name == 'svm.SVR.predict':
-            return hasattr(self, '_onedal_estimator')
-
     def _onedal_fit(self, X, y, sample_weight=None, queue=None):
         onedal_params = {
             'C': self.C,
             'epsilon': self.epsilon,
             'kernel': self.kernel,
             'degree': self.degree,
             'gamma': self.gamma,
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/svm/tests/test_svm.py` & `sklearnex/svm/tests/test_svm.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/_models_info.py` & `sklearnex/tests/_models_info.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_config.py` & `sklearnex/tests/test_config.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_memory_usage.py` & `sklearnex/tests/test_memory_usage.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,18 +15,24 @@
 #===============================================================================
 
 import pytest
 import types
 import tracemalloc
 from sklearnex import get_patch_map
 from sklearnex.model_selection import train_test_split
-from sklearnex.utils import assert_all_finite
+from sklearnex.utils import _assert_all_finite
 from sklearnex.metrics import pairwise_distances, roc_auc_score
 from sklearnex.preview.decomposition import PCA as PreviewPCA
 from sklearnex.preview.linear_model import LinearRegression as PreviewLinearRegression
+from sklearnex.preview.ensemble import (
+    RandomForestClassifier as PreviewRandomForestClassifier,
+    RandomForestRegressor as PreviewRandomForestRegressor,
+    ExtraTreesClassifier as PreviewExtraTreesClassifier,
+    ExtraTreesRegressor as PreviewExtraTreesRegressor
+)
 from sklearn.base import BaseEstimator
 from sklearn.model_selection import KFold
 from sklearn.datasets import make_classification
 from scipy.stats import pearsonr
 import pandas as pd
 import numpy as np
 import gc
@@ -42,16 +48,16 @@
 
 
 class FiniteCheckEstimator:
     def __init__(self):
         pass
 
     def fit(self, x, y):
-        assert_all_finite(x)
-        assert_all_finite(y)
+        _assert_all_finite(x)
+        _assert_all_finite(y)
 
 
 class PairwiseDistancesEstimator:
     def fit(self, x, y):
         pairwise_distances(x, metric=self.metric)
 
 
@@ -69,42 +75,53 @@
     def __init__(self):
         pass
 
     def fit(self, x, y):
         print(roc_auc_score(y, np.zeros(shape=y.shape, dtype=np.int32)))
 
 
-# add all daa4lpy estimators enabled in patching (except banned)
+# add all daal4py estimators enabled in patching (except banned)
 def get_patched_estimators(ban_list, output_list):
     patched_estimators = get_patch_map().values()
     for listing in patched_estimators:
         estimator, name = listing[0][0][2], listing[0][0][1]
         if not isinstance(estimator, types.FunctionType):
             if name not in ban_list:
                 if isinstance(estimator(), BaseEstimator):
                     if hasattr(estimator, 'fit'):
                         output_list.append(estimator)
 
 
+def remove_duplicated_estimators(estimators_list):
+    estimators_map = {}
+    for estimator in estimators_list:
+        full_name = f'{estimator.__module__}.{estimator.__name__}'
+        estimators_map[full_name] = estimator
+    return estimators_map.values()
+
+
 BANNED_ESTIMATORS = (
     'LocalOutlierFactor',  # fails on ndarray_c for sklearn > 1.0
     'TSNE',  # too slow for using in testing on common data size
-    'RandomForestClassifier',  # Failed, need to investigate and fix this issue
-    'RandomForestRegressor',  # Failed, need to investigate and fix this issue
 )
 estimators = [
     PreviewPCA,
     PreviewLinearRegression,
+    PreviewRandomForestClassifier,
+    PreviewRandomForestRegressor,
+    PreviewExtraTreesClassifier,
+    PreviewExtraTreesRegressor,
     TrainTestSplitEstimator,
     FiniteCheckEstimator,
     CosineDistancesEstimator,
     CorrelationDistancesEstimator,
     RocAucEstimator
 ]
 get_patched_estimators(BANNED_ESTIMATORS, estimators)
+estimators = remove_duplicated_estimators(estimators)
 
 
 def ndarray_c(x, y):
     return np.ascontiguousarray(x), y
 
 
 def ndarray_f(x, y):
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_monkeypatch.py` & `sklearnex/tests/test_monkeypatch.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_patching.py` & `sklearnex/tests/test_patching.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,90 +1,121 @@
-#===============================================================================
+# ===============================================================================
 # Copyright 2021 Intel Corporation
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-#===============================================================================
+# ===============================================================================
 
+import os
+import pathlib
 import re
 import subprocess
 import sys
-import os
-import pathlib
+from inspect import isclass
+
 import pytest
 from _models_info import TO_SKIP
+from sklearn.base import BaseEstimator
+
+from sklearnex import get_patch_map, is_patched_instance, patch_sklearn, unpatch_sklearn
 
 
 def get_branch(s):
     if len(s) == 0:
-        return 'NO INFO'
+        return "NO INFO"
     for i in s:
-        if 'failed to run accelerated version, fallback to original Scikit-learn' in i:
-            return 'was in OPT, but go in Scikit'
+        if "failed to run accelerated version, fallback to original Scikit-learn" in i:
+            return "was in OPT, but go in Scikit"
     for i in s:
-        if 'running accelerated version' in i:
-            return 'OPT'
-    return 'Scikit'
+        if "running accelerated version" in i:
+            return "OPT"
+    return "Scikit"
 
 
 def run_parse(mas, result):
     name, dtype = mas[0].split()
     temp = []
     INFO_POS = 16
     for i in range(1, len(mas)):
         mas[i] = mas[i][INFO_POS:]  # remove 'SKLEARNEX INFO: '
-        if not mas[i].startswith('sklearn'):
-            ind = name + ' ' + dtype + ' ' + mas[i]
+        if not mas[i].startswith("sklearn"):
+            ind = name + " " + dtype + " " + mas[i]
             result[ind] = get_branch(temp)
             temp.clear()
         else:
             temp.append(mas[i])
 
 
 def get_result_log():
-    os.environ['SKLEARNEX_VERBOSE'] = 'INFO'
+    os.environ["SKLEARNEX_VERBOSE"] = "INFO"
     absolute_path = str(pathlib.Path(__file__).parent.absolute())
     try:
         process = subprocess.check_output(
-            [
-                sys.executable,
-                absolute_path + '/utils/_launch_algorithms.py'
-            ]
+            [sys.executable, absolute_path + "/utils/_launch_algorithms.py"]
         )
     except subprocess.CalledProcessError as e:
         print(e)
         exit(1)
     mas = []
     result = {}
-    for i in process.decode().split('\n'):
-        if i.startswith('SKLEARNEX WARNING'):
+    for i in process.decode().split("\n"):
+        if i.startswith("SKLEARNEX WARNING"):
             continue
-        if not i.startswith('SKLEARNEX INFO') and len(mas) != 0:
+        if not i.startswith("SKLEARNEX INFO") and len(mas) != 0:
             run_parse(mas, result)
             mas.clear()
             mas.append(i.strip())
         else:
             mas.append(i.strip())
-    del os.environ['SKLEARNEX_VERBOSE']
+    del os.environ["SKLEARNEX_VERBOSE"]
     return result
 
 
 result_log = get_result_log()
 
 
-@pytest.mark.parametrize('configuration', result_log)
+@pytest.mark.parametrize("configuration", result_log)
 def test_patching(configuration):
-    if 'OPT' in result_log[configuration]:
+    if "OPT" in result_log[configuration]:
         return
     for skip in TO_SKIP:
         if re.search(skip, configuration) is not None:
             pytest.skip("SKIPPED", allow_module_level=False)
-    raise ValueError('Test patching failed: ' + configuration)
+    raise ValueError("Test patching failed: " + configuration)
+
+
+def _load_all_models(patched):
+    if patched:
+        patch_sklearn()
+
+    models = []
+    for patch_infos in get_patch_map().values():
+        maybe_class = getattr(patch_infos[0][0][0], patch_infos[0][0][1])
+        if maybe_class is not None and isclass(maybe_class) and \
+                issubclass(maybe_class, BaseEstimator):
+            models.append(maybe_class())
+
+    if patched:
+        unpatch_sklearn()
+
+    return models
+
+
+PATCHED_MODELS = _load_all_models(patched=True)
+UNPATCHED_MODELS = _load_all_models(patched=False)
+
+
+@pytest.mark.parametrize(
+    ("patched", "unpatched"), zip(PATCHED_MODELS, UNPATCHED_MODELS)
+)
+def test_is_patched_instance(patched, unpatched):
+    assert is_patched_instance(patched), f"{patched} is a patched instance"
+    assert not is_patched_instance(unpatched), f"{unpatched} is an unpatched instance"
```

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/test_run_to_run_stability_tests.py` & `sklearnex/tests/test_run_to_run_stability_tests.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/tests/utils/_launch_algorithms.py` & `sklearnex/tests/utils/_launch_algorithms.py`

 * *Files identical despite different names*

## Comparing `scikit_learn_intelex-2023.1.1.data/data/Lib/site-packages/sklearnex/utils/__init__.py` & `sklearnex/utils/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -10,10 +10,10 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #===============================================================================
 
-from .validation import assert_all_finite
+from .validation import _assert_all_finite
 
-__all__ = ['assert_all_finite']
+__all__ = ['_assert_all_finite']
```

## Comparing `scikit_learn_intelex-2023.1.1.dist-info/LICENSE.txt` & `scikit_learn_intelex-2023.2.0.dist-info/LICENSE.txt`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,202 +1,202 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
- 1. Definitions.
-
-  "License" shall mean the terms and conditions for use, reproduction,
-  and distribution as defined by Sections 1 through 9 of this document.
-
-  "Licensor" shall mean the copyright owner or entity authorized by
-  the copyright owner that is granting the License.
-
-  "Legal Entity" shall mean the union of the acting entity and all
-  other entities that control, are controlled by, or are under common
-  control with that entity. For the purposes of this definition,
-  "control" means (i) the power, direct or indirect, to cause the
-  direction or management of such entity, whether by contract or
-  otherwise, or (ii) ownership of fifty percent (50%) or more of the
-  outstanding shares, or (iii) beneficial ownership of such entity.
-
-  "You" (or "Your") shall mean an individual or Legal Entity
-  exercising permissions granted by this License.
-
-  "Source" form shall mean the preferred form for making modifications,
-  including but not limited to software source code, documentation
-  source, and configuration files.
-
-  "Object" form shall mean any form resulting from mechanical
-  transformation or translation of a Source form, including but
-  not limited to compiled object code, generated documentation,
-  and conversions to other media types.
-
-  "Work" shall mean the work of authorship, whether in Source or
-  Object form, made available under the License, as indicated by a
-  copyright notice that is included in or attached to the work
-  (an example is provided in the Appendix below).
-
-  "Derivative Works" shall mean any work, whether in Source or Object
-  form, that is based on (or derived from) the Work and for which the
-  editorial revisions, annotations, elaborations, or other modifications
-  represent, as a whole, an original work of authorship. For the purposes
-  of this License, Derivative Works shall not include works that remain
-  separable from, or merely link (or bind by name) to the interfaces of,
-  the Work and Derivative Works thereof.
-
-  "Contribution" shall mean any work of authorship, including
-  the original version of the Work and any modifications or additions
-  to that Work or Derivative Works thereof, that is intentionally
-  submitted to Licensor for inclusion in the Work by the copyright owner
-  or by an individual or Legal Entity authorized to submit on behalf of
-  the copyright owner. For the purposes of this definition, "submitted"
-  means any form of electronic, verbal, or written communication sent
-  to the Licensor or its representatives, including but not limited to
-  communication on electronic mailing lists, source code control systems,
-  and issue tracking systems that are managed by, or on behalf of, the
-  Licensor for the purpose of discussing and improving the Work, but
-  excluding communication that is conspicuously marked or otherwise
-  designated in writing by the copyright owner as "Not a Contribution."
-
-  "Contributor" shall mean Licensor and any individual or Legal Entity
-  on behalf of whom a Contribution has been received by Licensor and
-  subsequently incorporated within the Work.
-
- 2. Grant of Copyright License. Subject to the terms and conditions of
-  this License, each Contributor hereby grants to You a perpetual,
-  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-  copyright license to reproduce, prepare Derivative Works of,
-  publicly display, publicly perform, sublicense, and distribute the
-  Work and such Derivative Works in Source or Object form.
-
- 3. Grant of Patent License. Subject to the terms and conditions of
-  this License, each Contributor hereby grants to You a perpetual,
-  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-  (except as stated in this section) patent license to make, have made,
-  use, offer to sell, sell, import, and otherwise transfer the Work,
-  where such license applies only to those patent claims licensable
-  by such Contributor that are necessarily infringed by their
-  Contribution(s) alone or by combination of their Contribution(s)
-  with the Work to which such Contribution(s) was submitted. If You
-  institute patent litigation against any entity (including a
-  cross-claim or counterclaim in a lawsuit) alleging that the Work
-  or a Contribution incorporated within the Work constitutes direct
-  or contributory patent infringement, then any patent licenses
-  granted to You under this License for that Work shall terminate
-  as of the date such litigation is filed.
-
- 4. Redistribution. You may reproduce and distribute copies of the
-  Work or Derivative Works thereof in any medium, with or without
-  modifications, and in Source or Object form, provided that You
-  meet the following conditions:
-
-  (a) You must give any other recipients of the Work or
-      Derivative Works a copy of this License; and
-
-  (b) You must cause any modified files to carry prominent notices
-      stating that You changed the files; and
-
-  (c) You must retain, in the Source form of any Derivative Works
-      that You distribute, all copyright, patent, trademark, and
-      attribution notices from the Source form of the Work,
-      excluding those notices that do not pertain to any part of
-      the Derivative Works; and
-
-  (d) If the Work includes a "NOTICE" text file as part of its
-      distribution, then any Derivative Works that You distribute must
-      include a readable copy of the attribution notices contained
-      within such NOTICE file, excluding those notices that do not
-      pertain to any part of the Derivative Works, in at least one
-      of the following places: within a NOTICE text file distributed
-      as part of the Derivative Works; within the Source form or
-      documentation, if provided along with the Derivative Works; or,
-      within a display generated by the Derivative Works, if and
-      wherever such third-party notices normally appear. The contents
-      of the NOTICE file are for informational purposes only and
-      do not modify the License. You may add Your own attribution
-      notices within Derivative Works that You distribute, alongside
-      or as an addendum to the NOTICE text from the Work, provided
-      that such additional attribution notices cannot be construed
-      as modifying the License.
-
-  You may add Your own copyright statement to Your modifications and
-  may provide additional or different license terms and conditions
-  for use, reproduction, or distribution of Your modifications, or
-  for any such Derivative Works as a whole, provided Your use,
-  reproduction, and distribution of the Work otherwise complies with
-  the conditions stated in this License.
-
- 5. Submission of Contributions. Unless You explicitly state otherwise,
-  any Contribution intentionally submitted for inclusion in the Work
-  by You to the Licensor shall be under the terms and conditions of
-  this License, without any additional terms or conditions.
-  Notwithstanding the above, nothing herein shall supersede or modify
-  the terms of any separate license agreement you may have executed
-  with Licensor regarding such Contributions.
-
- 6. Trademarks. This License does not grant permission to use the trade
-  names, trademarks, service marks, or product names of the Licensor,
-  except as required for reasonable and customary use in describing the
-  origin of the Work and reproducing the content of the NOTICE file.
-
- 7. Disclaimer of Warranty. Unless required by applicable law or
-  agreed to in writing, Licensor provides the Work (and each
-  Contributor provides its Contributions) on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-  implied, including, without limitation, any warranties or conditions
-  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-  PARTICULAR PURPOSE. You are solely responsible for determining the
-  appropriateness of using or redistributing the Work and assume any
-  risks associated with Your exercise of permissions under this License.
-
- 8. Limitation of Liability. In no event and under no legal theory,
-  whether in tort (including negligence), contract, or otherwise,
-  unless required by applicable law (such as deliberate and grossly
-  negligent acts) or agreed to in writing, shall any Contributor be
-  liable to You for damages, including any direct, indirect, special,
-  incidental, or consequential damages of any character arising as a
-  result of this License or out of the use or inability to use the
-  Work (including but not limited to damages for loss of goodwill,
-  work stoppage, computer failure or malfunction, or any and all
-  other commercial damages or losses), even if such Contributor
-  has been advised of the possibility of such damages.
-
- 9. Accepting Warranty or Additional Liability. While redistributing
-  the Work or Derivative Works thereof, You may choose to offer,
-  and charge a fee for, acceptance of support, warranty, indemnity,
-  or other liability obligations and/or rights consistent with this
-  License. However, in accepting such obligations, You may act only
-  on Your own behalf and on Your sole responsibility, not on behalf
-  of any other Contributor, and only if You agree to indemnify,
-  defend, and hold each Contributor harmless for any liability
-  incurred by, or claims asserted against, such Contributor by reason
-  of your accepting any such warranty or additional liability.
-
- END OF TERMS AND CONDITIONS
-
- APPENDIX: How to apply the Apache License to your work.
-
-  To apply the Apache License to your work, attach the following
-  boilerplate notice, with the fields enclosed by brackets "[]"
-  replaced with your own identifying information. (Don't include
-  the brackets!)  The text should be enclosed in the appropriate
-  comment syntax for the file format. We also recommend that a
-  file or class name and description of purpose be included on the
-  same "printed page" as the copyright notice for easier
-  identification within third-party archives.
- Copyright 2017, The TensorFlow Authors.
-
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-  http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-
-* Other names and brands may be claimed as the property of others.
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+ 1. Definitions.
+
+  "License" shall mean the terms and conditions for use, reproduction,
+  and distribution as defined by Sections 1 through 9 of this document.
+
+  "Licensor" shall mean the copyright owner or entity authorized by
+  the copyright owner that is granting the License.
+
+  "Legal Entity" shall mean the union of the acting entity and all
+  other entities that control, are controlled by, or are under common
+  control with that entity. For the purposes of this definition,
+  "control" means (i) the power, direct or indirect, to cause the
+  direction or management of such entity, whether by contract or
+  otherwise, or (ii) ownership of fifty percent (50%) or more of the
+  outstanding shares, or (iii) beneficial ownership of such entity.
+
+  "You" (or "Your") shall mean an individual or Legal Entity
+  exercising permissions granted by this License.
+
+  "Source" form shall mean the preferred form for making modifications,
+  including but not limited to software source code, documentation
+  source, and configuration files.
+
+  "Object" form shall mean any form resulting from mechanical
+  transformation or translation of a Source form, including but
+  not limited to compiled object code, generated documentation,
+  and conversions to other media types.
+
+  "Work" shall mean the work of authorship, whether in Source or
+  Object form, made available under the License, as indicated by a
+  copyright notice that is included in or attached to the work
+  (an example is provided in the Appendix below).
+
+  "Derivative Works" shall mean any work, whether in Source or Object
+  form, that is based on (or derived from) the Work and for which the
+  editorial revisions, annotations, elaborations, or other modifications
+  represent, as a whole, an original work of authorship. For the purposes
+  of this License, Derivative Works shall not include works that remain
+  separable from, or merely link (or bind by name) to the interfaces of,
+  the Work and Derivative Works thereof.
+
+  "Contribution" shall mean any work of authorship, including
+  the original version of the Work and any modifications or additions
+  to that Work or Derivative Works thereof, that is intentionally
+  submitted to Licensor for inclusion in the Work by the copyright owner
+  or by an individual or Legal Entity authorized to submit on behalf of
+  the copyright owner. For the purposes of this definition, "submitted"
+  means any form of electronic, verbal, or written communication sent
+  to the Licensor or its representatives, including but not limited to
+  communication on electronic mailing lists, source code control systems,
+  and issue tracking systems that are managed by, or on behalf of, the
+  Licensor for the purpose of discussing and improving the Work, but
+  excluding communication that is conspicuously marked or otherwise
+  designated in writing by the copyright owner as "Not a Contribution."
+
+  "Contributor" shall mean Licensor and any individual or Legal Entity
+  on behalf of whom a Contribution has been received by Licensor and
+  subsequently incorporated within the Work.
+
+ 2. Grant of Copyright License. Subject to the terms and conditions of
+  this License, each Contributor hereby grants to You a perpetual,
+  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+  copyright license to reproduce, prepare Derivative Works of,
+  publicly display, publicly perform, sublicense, and distribute the
+  Work and such Derivative Works in Source or Object form.
+
+ 3. Grant of Patent License. Subject to the terms and conditions of
+  this License, each Contributor hereby grants to You a perpetual,
+  worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+  (except as stated in this section) patent license to make, have made,
+  use, offer to sell, sell, import, and otherwise transfer the Work,
+  where such license applies only to those patent claims licensable
+  by such Contributor that are necessarily infringed by their
+  Contribution(s) alone or by combination of their Contribution(s)
+  with the Work to which such Contribution(s) was submitted. If You
+  institute patent litigation against any entity (including a
+  cross-claim or counterclaim in a lawsuit) alleging that the Work
+  or a Contribution incorporated within the Work constitutes direct
+  or contributory patent infringement, then any patent licenses
+  granted to You under this License for that Work shall terminate
+  as of the date such litigation is filed.
+
+ 4. Redistribution. You may reproduce and distribute copies of the
+  Work or Derivative Works thereof in any medium, with or without
+  modifications, and in Source or Object form, provided that You
+  meet the following conditions:
+
+  (a) You must give any other recipients of the Work or
+      Derivative Works a copy of this License; and
+
+  (b) You must cause any modified files to carry prominent notices
+      stating that You changed the files; and
+
+  (c) You must retain, in the Source form of any Derivative Works
+      that You distribute, all copyright, patent, trademark, and
+      attribution notices from the Source form of the Work,
+      excluding those notices that do not pertain to any part of
+      the Derivative Works; and
+
+  (d) If the Work includes a "NOTICE" text file as part of its
+      distribution, then any Derivative Works that You distribute must
+      include a readable copy of the attribution notices contained
+      within such NOTICE file, excluding those notices that do not
+      pertain to any part of the Derivative Works, in at least one
+      of the following places: within a NOTICE text file distributed
+      as part of the Derivative Works; within the Source form or
+      documentation, if provided along with the Derivative Works; or,
+      within a display generated by the Derivative Works, if and
+      wherever such third-party notices normally appear. The contents
+      of the NOTICE file are for informational purposes only and
+      do not modify the License. You may add Your own attribution
+      notices within Derivative Works that You distribute, alongside
+      or as an addendum to the NOTICE text from the Work, provided
+      that such additional attribution notices cannot be construed
+      as modifying the License.
+
+  You may add Your own copyright statement to Your modifications and
+  may provide additional or different license terms and conditions
+  for use, reproduction, or distribution of Your modifications, or
+  for any such Derivative Works as a whole, provided Your use,
+  reproduction, and distribution of the Work otherwise complies with
+  the conditions stated in this License.
+
+ 5. Submission of Contributions. Unless You explicitly state otherwise,
+  any Contribution intentionally submitted for inclusion in the Work
+  by You to the Licensor shall be under the terms and conditions of
+  this License, without any additional terms or conditions.
+  Notwithstanding the above, nothing herein shall supersede or modify
+  the terms of any separate license agreement you may have executed
+  with Licensor regarding such Contributions.
+
+ 6. Trademarks. This License does not grant permission to use the trade
+  names, trademarks, service marks, or product names of the Licensor,
+  except as required for reasonable and customary use in describing the
+  origin of the Work and reproducing the content of the NOTICE file.
+
+ 7. Disclaimer of Warranty. Unless required by applicable law or
+  agreed to in writing, Licensor provides the Work (and each
+  Contributor provides its Contributions) on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+  implied, including, without limitation, any warranties or conditions
+  of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+  PARTICULAR PURPOSE. You are solely responsible for determining the
+  appropriateness of using or redistributing the Work and assume any
+  risks associated with Your exercise of permissions under this License.
+
+ 8. Limitation of Liability. In no event and under no legal theory,
+  whether in tort (including negligence), contract, or otherwise,
+  unless required by applicable law (such as deliberate and grossly
+  negligent acts) or agreed to in writing, shall any Contributor be
+  liable to You for damages, including any direct, indirect, special,
+  incidental, or consequential damages of any character arising as a
+  result of this License or out of the use or inability to use the
+  Work (including but not limited to damages for loss of goodwill,
+  work stoppage, computer failure or malfunction, or any and all
+  other commercial damages or losses), even if such Contributor
+  has been advised of the possibility of such damages.
+
+ 9. Accepting Warranty or Additional Liability. While redistributing
+  the Work or Derivative Works thereof, You may choose to offer,
+  and charge a fee for, acceptance of support, warranty, indemnity,
+  or other liability obligations and/or rights consistent with this
+  License. However, in accepting such obligations, You may act only
+  on Your own behalf and on Your sole responsibility, not on behalf
+  of any other Contributor, and only if You agree to indemnify,
+  defend, and hold each Contributor harmless for any liability
+  incurred by, or claims asserted against, such Contributor by reason
+  of your accepting any such warranty or additional liability.
+
+ END OF TERMS AND CONDITIONS
+
+ APPENDIX: How to apply the Apache License to your work.
+
+  To apply the Apache License to your work, attach the following
+  boilerplate notice, with the fields enclosed by brackets "[]"
+  replaced with your own identifying information. (Don't include
+  the brackets!)  The text should be enclosed in the appropriate
+  comment syntax for the file format. We also recommend that a
+  file or class name and description of purpose be included on the
+  same "printed page" as the copyright notice for easier
+  identification within third-party archives.
+ Copyright 2017, The TensorFlow Authors.
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+
+* Other names and brands may be claimed as the property of others.
```

## Comparing `scikit_learn_intelex-2023.1.1.dist-info/METADATA` & `scikit_learn_intelex-2023.2.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 Metadata-Version: 2.1
 Name: scikit-learn-intelex
-Version: 2023.1.1
+Version: 2023.2.0
 Summary: Intel(R) Extension for Scikit-learn is a seamless way to speed up your Scikit-learn application.
 Home-page: https://github.com/intel/scikit-learn-intelex
 Author: Intel Corporation
 Author-email: scripting@intel.com
 Maintainer-email: onedal.maintainers@intel.com
-License: Apache-2.0
+License: Apache v2.0
 Project-URL: Bug Tracker, https://github.com/intel/scikit-learn-intelex/issues
 Project-URL: Documentation, https://intel.github.io/scikit-learn-intelex/
 Project-URL: Source Code, https://github.com/intel/scikit-learn-intelex
 Keywords: machine learning,scikit-learn,data science,data analytics
-Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Environment :: Console
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Other Audience
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: MacOS :: MacOS X
@@ -28,15 +27,15 @@
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: System
 Classifier: Topic :: Software Development
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
-Requires-Dist: daal4py (==2023.1.1)
+Requires-Dist: daal4py (==2023.2.0)
 Requires-Dist: scikit-learn (>=0.22)
 
 
 # Intel(R) Extension for Scikit-learn*
 
 [![Build Status](https://dev.azure.com/daal/daal4py/_apis/build/status/CI?branchName=master)](https://dev.azure.com/daal/daal4py/_build/latest?definitionId=9&branchName=master)
 [![Coverity Scan Build Status](https://scan.coverity.com/projects/21716/badge.svg)](https://scan.coverity.com/projects/daal4py)
@@ -223,9 +222,7 @@
 - On Windows: `set SKLEARNEX_VERBOSE=INFO`
 
 For example, for DBSCAN you get one of these print statements depending on which implementation is used:
 - `SKLEARNEX INFO: sklearn.cluster.DBSCAN.fit: running accelerated version on CPU`
 - `SKLEARNEX INFO: sklearn.cluster.DBSCAN.fit: fallback to original Scikit-learn`
 
 [Read more in the documentation](https://intel.github.io/scikit-learn-intelex/).
-
-
```

